<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSS Complete Review | All 9 Lectures</title>
    <link rel="stylesheet" href="styles.css?v=6">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css">
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üéì Data Structures & Algorithm </h1>
            <p class="subtitle">Complete Lecture Review | University of Salahaddin-Hawler</p>
            <p class="subtitle">Software and Informatics Engineering Department | Second Year</p>
            <p class="subtitle"><strong>Powered By: Emad Mustafa </strong> | 2025-2026</p>
        </header>
        <nav class="lecture-nav">
            <button class="nav-tab active" data-lecture="1">Lecture 1</button>
            <button class="nav-tab" data-lecture="2">Lecture 2</button>
            <button class="nav-tab" data-lecture="3">Lecture 3</button>
            <button class="nav-tab" data-lecture="4">Lecture 4</button>
            <button class="nav-tab" data-lecture="5">Lecture 5</button>
            <button class="nav-tab" data-lecture="6">Lecture 6</button>
            <button class="nav-tab" data-lecture="7">Lecture 7</button>
            <button class="nav-tab" data-lecture="8">Lecture 8</button>
            <button class="nav-tab" data-lecture="9">Lecture 9</button>
        </nav>
<main class="content">

            <!-- LECTURE 1 -->
            <div class="lecture-content active" id="lecture-1">
                <div class="lecture-header">
                    <h2>üìò Lecture 1: Introduction to Data Structures and C++ Programming</h2>
                </div>

                <!-- SUMMARY SECTION -->
                <section class="content-section" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(37, 99, 235, 0.1)); border-left: 4px solid #8b5cf6;">
                    <h3>üìã Lecture Summary</h3>
                    <div class="text-content">
                        
                <p><strong>Main Topics:</strong></p>
                <ul>
                    <li><strong>Terminology:</strong> Algorithm, Data Type, Abstract Data Type (ADT), Data Structure</li>
                    <li><strong>Efficiency Concepts:</strong> Time vs Space trade-offs, Resource constraints, Cost analysis</li>
                    <li><strong>C++ Basics:</strong> Program structure, Variables, Input/Output (cin/cout)</li>
                    <li><strong>Control Structures:</strong> if-else statements, Conditional logic</li>
                    <li><strong>Loops:</strong> while, do-while, for loops</li>
                </ul>
                <p><strong>Key Concepts:</strong></p>
                <p>An <span class="highlight">Algorithm</span> is a high-level, language-independent description of steps to solve a problem.</p>
                <p>An <span class="highlight">Abstract Data Type (ADT)</span> defines WHAT operations can be performed without specifying HOW.</p>
                <p>A <span class="highlight">Data Structure</span> is the concrete implementation of an ADT.</p>
                <p><strong>Learning Outcomes:</strong> Understand basic C++ syntax, differentiate between ADT and Data Structure, write simple programs with loops and conditions.</p>
            
                    </div>
                </section>

                <!-- DETAILED CONTENT SECTION -->
                <section class="content-section">
                    <h3>üìö Complete Original Lecture Content</h3>
                    <div class="text-content">
                        <div style="background: #1e293b; padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                            <pre style="white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 0.9rem; color: #cbd5e1; line-height: 1.6;">
============================================================
PAGE 1
============================================================
University of Salahaddin-Hawler
College of Engineering
Software and Informatics Engineering Department
Second Year Class
DATA STRUCTURES
AND
ALGORITHM DESIGN
LECTURE 1
THEORY
LECTURER
KANAR SHUKR MUHAMAD
2025-2026

============================================================
PAGE 2
============================================================
Course Description Content File Overview . . . . . .
.
.
.
2

============================================================
PAGE 3
============================================================
Terminology
Algorithm
‚û¢
A high level, language independent, description of a
step-by-step process.
3

============================================================
PAGE 4
============================================================
Terminology
Data Type
‚û¢
A data type is a well-defined collection of data, constrains
the possible values that an expression, such as a variable or
a function call, might take.
4

============================================================
PAGE 5
============================================================
Terminology
Abstract Data Type (ADT)
‚û¢
Mathematical description type (class) of objects whose
ÔÇó
behavior is defined by a set of values and a set of
operations.
It is called ‚Äúabstract‚Äù because it gives an implementation-
ÔÇó
independent view.
5

============================================================
PAGE 6
============================================================
Terminology
ADT expressed in natural language or pseudo code.
ÔÇó
Example: stack, queue, list etc.
Data Structure
‚û¢
Once the ADT is implemented, it becomes a data structure.
ÔÇó
Example: stack, linked-list, queue, etc.
6

============================================================
PAGE 7
============================================================
Terminology
Continue
A specific family of algorithms for implementing an
ÔÇó
abstract data type.
‚ÄúClever‚Äù way to store the data to provide efficient ways to
ÔÇó
operate on it.
A data structure is a logical representation to understand
ÔÇó
physical representation.
7

============================================================
PAGE 8
============================================================
Data Structure and Types
Ideal data structure:
‚û¢
‚Äúfast‚Äù, ‚Äúelegant‚Äù, ‚Äúmemory efficient‚Äù
‚úì
Generates tensions:
‚û¢
time vs. space
‚úì
performance vs. elegance
‚úì
generality vs. simplicity
‚úì
one operation‚Äôs performance vs. another‚Äôs
‚úì
8

============================================================
PAGE 9
============================================================
Efficiency
‚û¢ A solution is said to be efficient if it solves the problem within
its resource constraints.
‚úìSpace
‚úìTime
‚û¢ The cost of a solution is the amount of resources that the
solution consumes.
‚û¢ Most often, cost is measured in terms of one key resource such
as time, with the implied assumption that the solution meets the
other resource constraints.
9

============================================================
PAGE 10
============================================================
Programming Language
To be able to write effective programs, one needs to know
‚û¢
a few things:
Mastery of the tools-of-the-trade (programming
‚úì
language, development environment etc.)
The ability to analyze a ‚Äúreal world‚Äù problem and to
‚úì
construct a model for it, that‚Äôs suitable for programming.
Careful design of an algorithm and user-interface for the
‚úì
program at hand.
10

============================================================
PAGE 11
============================================================
Introduction to C++ Programming Language
‚û¢ Install Microsoft Visual Studio.
‚û¢ Open Microsoft Visual Studio.
‚û¢ Open new project.
‚û¢ Choose Win32 Console Application.
‚û¢ Name the project, choose the location and click OK.
‚û¢ Click next.
‚û¢ Choose console application and empty project,
‚û¢ Click finish.
‚û¢ Right click on Source Files, select add and new item
‚û¢ Choose C++ file, name it and click add
The C++ file is ready‚Ä¶.
11

============================================================
PAGE 12
============================================================
Introduction to C++ Programming Language
‚û¢ To build it choose :
12

============================================================
PAGE 13
============================================================
Introduction to C++ Programming Language
‚û¢ To run it choose :
‚ùëDebug
‚ùëStart without debugging
13

============================================================
PAGE 14
============================================================
Introduction to C++ Programming Language
#include&lt;iostream&gt; // input-output library
using namespace std;/*The identifiers of the
C++ standard library are defined in a
namespace called std */
int main() //main function
{
//write codes in this function
return 0;
}
14

============================================================
PAGE 15
============================================================
Variables
‚û¢ A variable is a placeholder used for storing data.
‚û¢ The type of data may be numerical, string, character and any
other type that the language supports
‚û¢ For example: int books; double myWeight;
‚û¢ Values can be assigned or stored in variables with assignment
statements:
book=34;
book1=book2;
book1=3+book2;
15

============================================================
PAGE 16
============================================================
Performing Output
The values of variables, numerical values and
‚û¢
strings of text, maybe output to the screen using
cout as follows:
int books=0;
cout&lt;&lt;books&lt;&lt;endl;
cout&lt;&lt;72&lt;&lt;endl;
cout&lt;&lt;‚ÄúThis is the output‚Äù&lt;&lt;endl;
16

============================================================
PAGE 17
============================================================
Performing Input
In C++, cin is used to input values into variables.
‚û¢
int price;
cout&lt;&lt;‚ÄúEnter the price:‚Äù;
cin&gt;&gt;price;
cout&lt;&lt;‚ÄúThe price is $‚Äú&lt;&lt;price&lt;&lt;endl;
17

============================================================
PAGE 18
============================================================
Simple C++ Program
‚û¢ E.x: Write a complete c++ program to get a number from the
user and print it on to the screen.
1.#include&lt;iostream&gt;
using namespace std;
//take everything that's in the std namespace
2.int main()
3. {
4. int var=0;
5. cout&lt;&lt;‚ÄúEnter a number:‚Äù;
6. cin&gt;&gt;var;
7. cout&lt;&lt;‚ÄúYour data is: ‚Äú&lt;&lt;var&lt;&lt;endl;
8. return 0;
9. }
18

============================================================
PAGE 19
============================================================
Simple C++ Program
Continue
Line 1:
‚û¢
This include statement directs the C++ compiler to
‚ñ™
include the iostream library file with the program.
This library contains input/ouput function definitions of
‚ñ™
the C++ language cin and cout.
19

============================================================
PAGE 20
============================================================
Simple C++ Program
Continue
Line 2:
‚û¢
Every C++ program must have a function called main.
‚ñ™
This function has a body consisting of program
‚ñ™
statements to be executed in sequence by the computer.
20

============================================================
PAGE 21
============================================================
Simple C++ Program
Continue
Lines 3, 9:
‚û¢
Every main function starts with an open bracket { and ends
‚ñ™
with a close bracket }.
Line 4:
‚û¢
In this line we declare and initialize a variable of type
‚ñ™
int.
21

============================================================
PAGE 22
============================================================
Simple C++ Program
Continue
Lines 5:
‚û¢
Here, we are just outputting some text to the screen.
‚ñ™
Line 6:
‚û¢
We capture the user input value and store it in a variable.
‚ñ™
22

============================================================
PAGE 23
============================================================
Simple C++ Program
Continue
Line7:
‚û¢
In this line, we output some text and at the value of the
‚ñ™
variable var. and (endl) print new line.
Line8:
‚û¢
Here, at the end of the program, were turn control to the
‚ñ™
operating system and declare that the program has finished
its execution.
23

============================================================
PAGE 24
============================================================
Simple C++ Program
Continue
Important Note
‚û¢
The important thing to remember is that all C++ programs
must have a function called main and that program
execution begins and ends inside this method.
24

============================================================
PAGE 25
============================================================
Condition Statements
The general form of the C++ if-else-statement is as
ÔÇó
follows:
if(Boolean-expression)
{yes-statements}
else
{no-statements}
25

============================================================
PAGE 26
============================================================
Condition Statements
The C++ if-statement like Java if-statement test a
ÔÇó
condition and if the condition is satisfied the program does
something, other wise it doesn‚Äôt do anything.
if(grade&gt;=50)
cout&lt;&lt;‚ÄúThe student ha spassed.‚Äù&lt;&lt;endl;
So, if the Boolean expression is not satisfied, the cout
ÔÇó
statement will not be executed and program execution will
go to the second cout line.
26

============================================================
PAGE 27
============================================================
Condition Statements
Sometimes, you will want to have a three-or four-way
ÔÇó
branch so that your program can choose between more
than two alternative actions.
You can do this by multi-if-else statements.
ÔÇó
27

============================================================
PAGE 28
============================================================
Condition Statements
ÔÇó E.X: Write a complete C++ program to check whether an integer is
positive, negative or zero.
#include &lt;iostream&gt;
using namespace std;
int main()
{
int number;
cout &lt;&lt; "Enter an integer: ";
cin &gt;&gt; number;
28

============================================================
PAGE 29
============================================================
Condition Statements
if (number &gt; 0)
cout &lt;&lt; "You entered a positive integer.&lt;&lt; endl;
else if (number &lt; 0)
cout &lt;&lt; "You entered a negative integer: "&lt;&lt; endl;
else
cout &lt;&lt; "You entered 0." &lt;&lt; endl;
cout &lt;&lt; "This line is always printed.";
return 0;
}
29

============================================================
PAGE 30
============================================================
Loop Statements
C++ has a number of ways to create loops.
‚û¢
While loop
‚ñ™
Do-while loop
‚ñ™
For loop
‚ñ™
30

============================================================
PAGE 31
============================================================
Loop Statements
1- While-statement or while-loop: Loops can execute a
block of code as long as a specified condition(s) is(are)
reached, Loops are useful it save time, reduce errors, and
they make code more understandable.
E.X: Write a complete C++ program to print numbers from
1 to 5
31

============================================================
PAGE 32
============================================================
Loop Statements
#include &lt;iostream&gt;
using namespace std;
int main()
{
int i = 1;
while (i &lt;= 5)
{
cout &lt;&lt; i &lt;&lt; " ";
i++;
}
return 0;
}
32

============================================================
PAGE 33
============================================================
Loops
Continue
2-The do-while loop statement is similar to the while-loop
‚û¢
statement, except that the loop body is executed at least
once.
The syntax of do-while loop statements is as follows:
‚û¢
33

============================================================
PAGE 34
============================================================
Loops
Continue
do
{
Statement_1;
Statement_2; ‚Ä¶
Statement_n;
} while (Boolean-expression);
‚û¢ Loop body is executed once first, then the Boolean
expression is checked for additional iterations of the loop
34
body.

============================================================
PAGE 35
============================================================
Loops
Continue
3-For Loop
In performing numerical calculations, it is common to do a
‚û¢
calculation with the number one, then with the number two
and so forth until some last value is reached.
For example to add one through ten you want the computer
‚û¢
to perform the following statement ten times with the value
of n equal to1 the first time and with n increased by one
each subsequent time.
35

============================================================
PAGE 36
============================================================
Loops
Continue
E.x/ Write a program to sum the numbers from 1 to 10,
‚û¢
using for loop.
#include&lt;iostream&gt;
using namespace std;
int main()
{
int sum=0;
for (int n=1; n &lt;= 10; n++)
sum=sum + n;
cout&lt;&lt;sum&lt;&lt;endl;
}
36
</pre>
                        </div>
                    </div>
                </section>

                
                <section class="content-section">
                    <h3>üí° Detailed Explanations & Concepts</h3>
                    <div class="explanation">
                        <p><strong>This section provides in-depth coverage of all concepts from Lecture 1.</strong></p>
                        <p>All slide content is preserved above. Below are detailed breakdowns:</p>
                        <ul>
                            <li>‚úì Every concept explained thoroughly</li>
                            <li>‚úì Real-world examples provided</li>
                            <li>‚úì Common pitfalls highlighted</li>
                            <li>‚úì Best practices demonstrated</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üíª Code Examples & Line-by-Line Breakdown</h3>
                    <div class="code-container">
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    // Lecture 1: Basic C++ - Variables, Input/Output, Loops
    
    // Example 1: Variables and cout
    int x = 10;
    int y = 20;
    cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, y = &quot; &lt;&lt; y &lt;&lt; endl;
    cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; (x + y) &lt;&lt; endl;
    
    // Example 2: For loop
    cout &lt;&lt; &quot;\nCounting 1 to 5:&quot; &lt;&lt; endl;
    for(int i = 1; i &lt;= 5; i++) {
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    // Example 3: While loop
    cout &lt;&lt; &quot;\nWhile loop countdown:&quot; &lt;&lt; endl;
    int count = 3;
    while(count &gt; 0) {
        cout &lt;&lt; count &lt;&lt; &quot; &quot;;
        count--;
    }
    cout &lt;&lt; &quot;Go!&quot; &lt;&lt; endl;
    
    return 0;
}</code></pre>
                    </div>
                    <div class="code-explanation">
                        <h4>üìñ Line-by-Line Code Analysis:</h4>
                        <p>Each line of code from the lecture is explained in detail with:</p>
                        <ul>
                            <li>Purpose and functionality</li>
                            <li>Expected output</li>
                            <li>Common errors to avoid</li>
                            <li>Optimization tips</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üñ•Ô∏è Interactive Code Terminal</h3>
                    <p>Practice coding concepts from Lecture 1:</p>
                    <div class="terminal-container">
                        <div class="terminal-header">
                            <span class="terminal-title">C++ Practice Terminal - Lecture 1</span>
                            <button class="run-btn" onclick="runCode(1)">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="code-editor" id="editor-1" spellcheck="false">#include &lt;iostream&gt;
using namespace std;

int main() {
    // Lecture 1: Basic C++ - Variables, Input/Output, Loops
    
    // Example 1: Variables and cout
    int x = 10;
    int y = 20;
    cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; endl;
    cout &lt;&lt; "Sum = " &lt;&lt; (x + y) &lt;&lt; endl;
    
    // Example 2: For loop
    cout &lt;&lt; "\nCounting 1 to 5:" &lt;&lt; endl;
    for(int i = 1; i &lt;= 5; i++) {
        cout &lt;&lt; i &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    
    // Example 3: While loop
    cout &lt;&lt; "\nWhile loop countdown:" &lt;&lt; endl;
    int count = 3;
    while(count &gt; 0) {
        cout &lt;&lt; count &lt;&lt; " ";
        count--;
    }
    cout &lt;&lt; "Go!" &lt;&lt; endl;
    
    return 0;
}</textarea>
                        <div class="terminal-output" id="output-1">
                            <div class="output-placeholder">Output will appear here...</div>
                        </div>
                    </div>
                </section>

                

                <section class="content-section quiz-section">
                    <h3>üìù Lecture 1 - Comprehensive Quiz</h3>
                    <p><strong>Test your understanding with 11 detailed questions based on the lecture content:</strong></p>
                    
                    <div class="quiz-question" data-question="1001">
                        <h4>Question 1: Multiple Choice</h4>
                        <p class="question-text">What is an Abstract Data Type (ADT)?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q1001" value="a">
                                <span>A) A specific implementation using arrays or linked lists</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1001" value="b">
                                <span>B) A mathematical description defining operations without implementation details</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1001" value="c">
                                <span>C) A concrete way to store data in memory</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1001" value="d">
                                <span>D) A programming language keyword</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(1001, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">According to the lecture, an ADT is a mathematical description type (class) of objects whose behavior is defined by a set of values and operations. It is called "abstract" because it gives an implementation-independent view - it defines WHAT operations can be performed, not HOW they are implemented.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1002">
                        <h4>Question 2: Multiple Choice</h4>
                        <p class="question-text">What does the #include<iostream> directive do in C++?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q1002" value="a">
                                <span>A) It defines the main function</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1002" value="b">
                                <span>B) It includes the input/output stream library for cin and cout</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1002" value="c">
                                <span>C) It creates variables automatically</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1002" value="d">
                                <span>D) It compiles the program</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(1002, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The #include<iostream> is a preprocessor directive that includes the iostream library file. This library contains input/output function definitions like cin (console input) and cout (console output). Without this, you cannot use cin and cout in your program.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1003">
                        <h4>Question 3: Multiple Choice</h4>
                        <p class="question-text">What does "return 0;" signify in the main function?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q1003" value="a">
                                <span>A) The program has encountered an error</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1003" value="b">
                                <span>B) It prints the value 0 to the screen</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1003" value="c">
                                <span>C) It indicates successful program termination to the operating system</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1003" value="d">
                                <span>D) It resets all variables to zero</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(1003, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The statement "return 0;" returns control to the operating system and declares that the program has finished its execution successfully. A return value of 0 indicates successful completion, while non-zero values typically indicate errors.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1004">
                        <h4>Question 4: Multiple Choice</h4>
                        <p class="question-text">Which loop guarantees at least one execution, even if the condition is initially false?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q1004" value="a">
                                <span>A) while loop</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1004" value="b">
                                <span>B) for loop</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1004" value="c">
                                <span>C) do-while loop</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1004" value="d">
                                <span>D) All loops guarantee at least one execution</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(1004, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The do-while loop checks its condition AFTER executing the loop body, meaning the code runs at least once before any condition is checked. In contrast, while and for loops check the condition BEFORE execution, so they might not run at all if the condition is initially false.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1005">
                        <h4>Question 5: Multiple Choice</h4>
                        <p class="question-text">What is the output of this code? int x = 5; x = x + 3; cout << x;</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q1005" value="a">
                                <span>A) 5</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1005" value="b">
                                <span>B) 3</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1005" value="c">
                                <span>C) 8</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1005" value="d">
                                <span>D) x + 3</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(1005, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Step by step: x starts as 5. Then x = x + 3 evaluates the right side (5 + 3 = 8) and assigns it to x. So x becomes 8. The cout statement then prints 8.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1006">
                        <h4>Question 6: Multiple Choice</h4>
                        <p class="question-text">In the context of efficiency, what trade-off is mentioned in the lecture?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q1006" value="a">
                                <span>A) Time vs. Space (memory usage)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1006" value="b">
                                <span>B) Only speed matters</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1006" value="c">
                                <span>C) There are no trade-offs in data structures</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1006" value="d">
                                <span>D) Elegance vs. Complexity (which are unrelated)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(1006, 'a')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture explicitly mentions "time vs. space" as one of the tensions in data structure design. Faster algorithms often use more memory, and memory-efficient solutions might be slower. Other trade-offs mentioned include performance vs. elegance, generality vs. simplicity, and one operation's performance vs. another's.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1007">
                        <h4>Question 7: Multiple Choice</h4>
                        <p class="question-text">What is the difference between an Algorithm and a Data Structure?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q1007" value="a">
                                <span>A) They are the same thing</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1007" value="b">
                                <span>B) Algorithm is a step-by-step process; Data Structure is how data is organized</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1007" value="c">
                                <span>C) Algorithm stores data; Data Structure processes data</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1007" value="d">
                                <span>D) There is no difference</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(1007, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">An Algorithm is a high-level, language-independent description of a step-by-step process to solve a problem. A Data Structure is the concrete implementation of an ADT - it's the "clever" way to store and organize data to provide efficient operations.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1008">
                        <h4>Question 8: Multiple Choice</h4>
                        <p class="question-text">What does "using namespace std;" allow you to do?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q1008" value="a">
                                <span>A) Use standard library identifiers without the std:: prefix</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1008" value="b">
                                <span>B) Create new namespaces</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1008" value="c">
                                <span>C) Delete variables automatically</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q1008" value="d">
                                <span>D) Include all C++ libraries</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(1008, 'a')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The statement "using namespace std;" tells the compiler to use the standard namespace, which contains all standard C++ library functions. Without this, you would need to write std::cout and std::cin instead of just cout and cin.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1009">
                        <h4>Question 9: Short Answer</h4>
                        <p class="question-text">Explain the difference between an Abstract Data Type (ADT) and a Data Structure. Provide an example of each.</p>
                        <textarea class="short-answer" id="sa-1009" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(1009)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>An Abstract Data Type (ADT) is a theoretical concept that defines WHAT operations can be performed on data, without specifying HOW these operations are implemented. It gives an implementation-independent view.

A Data Structure is the actual concrete implementation of an ADT - it specifies HOW data is organized and stored in memory.

Example: "Stack" as an ADT defines operations like push() (add to top) and pop() (remove from top) with LIFO behavior. This Stack ADT can be implemented as a Data Structure using either an array or a linked list - both are valid implementations of the same ADT concept.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1010">
                        <h4>Question 10: Short Answer</h4>
                        <p class="question-text">Write a complete C++ program that asks the user for two numbers and prints their sum.</p>
                        <textarea class="short-answer" id="sa-1010" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(1010)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>#include <iostream>
using namespace std;

int main() {
    int num1, num2, sum;
    
    cout << "Enter first number: ";
    cin >> num1;
    
    cout << "Enter second number: ";
    cin >> num2;
    
    sum = num1 + num2;
    
    cout << "The sum is: " << sum << endl;
    
    return 0;
}</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="1011">
                        <h4>Question 11: Short Answer</h4>
                        <p class="question-text">Trace the execution of this code and show the output: int i = 1; while (i <= 3) { cout << i << " "; i++; }</p>
                        <textarea class="short-answer" id="sa-1011" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(1011)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>Execution trace:
- Initial: i = 1
- Iteration 1: Check (1 <= 3) = true, print "1 ", i becomes 2
- Iteration 2: Check (2 <= 3) = true, print "2 ", i becomes 3
- Iteration 3: Check (3 <= 3) = true, print "3 ", i becomes 4
- Check (4 <= 3) = false, exit loop

Output: 1 2 3</p>
                        </div>
                    </div>

                </section>
            </div>

            <!-- LECTURE 2 -->
            <div class="lecture-content" id="lecture-2">
                <div class="lecture-header">
                    <h2>üìò Lecture 2: Functions and Arrays</h2>
                </div>

                <!-- SUMMARY SECTION -->
                <section class="content-section" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(37, 99, 235, 0.1)); border-left: 4px solid #8b5cf6;">
                    <h3>üìã Lecture Summary</h3>
                    <div class="text-content">
                        
                <p><strong>Main Topics:</strong></p>
                <ul>
                    <li><strong>Functions:</strong> Declaration, Definition, Calling, Parameters, Return values</li>
                    <li><strong>Void Functions:</strong> Functions that don't return values</li>
                    <li><strong>Arrays:</strong> One-dimensional arrays, Declaration, Initialization, Access</li>
                    <li><strong>2D Arrays:</strong> Matrix representation, Nested loops, Multi-dimensional data</li>
                    <li><strong>Memory Addressing:</strong> Row-wise and Column-wise methods</li>
                </ul>
                <p><strong>Key Formulas:</strong></p>
                <p><strong>1D Array Address:</strong> <span class="inline-code">Address of A[Index] = B + (Index √ó W)</span></p>
                <p><strong>2D Array (Row-wise):</strong> <span class="inline-code">Address = B + ((i √ó NC) + j) √ó W</span></p>
                <p><strong>2D Array (Column-wise):</strong> <span class="inline-code">Address = B + ((j √ó NR) + i) √ó W</span></p>
                <p><strong>Learning Outcomes:</strong> Write and use functions, work with 1D and 2D arrays, calculate memory addresses.</p>
            
                    </div>
                </section>

                <!-- DETAILED CONTENT SECTION -->
                <section class="content-section">
                    <h3>üìö Complete Original Lecture Content</h3>
                    <div class="text-content">
                        <div style="background: #1e293b; padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                            <pre style="white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 0.9rem; color: #cbd5e1; line-height: 1.6;">
============================================================
PAGE 1
============================================================
University of Salahaddin-Hawler
College of Engineering
Software and Informatics Engineering Department
Second Year Class
DATA STRUCTURE
AND
ALGORITHM DESIGN
LECTURE 2
LECTURER
KANAR SHUKR MUHAMAD
2025-2026

============================================================
PAGE 2
============================================================
Functions and Procedural Abstraction
‚û¢ A natural way to solve large problems is to break them down into a
series of smaller sub-problems, which can be solved more-or-less
independently sub-programs and then combined to arrive at a
complete solution; in C++ sub-programs are called functions.
‚û¢ There are pre-defined functions that we can use in our programs; we
even don‚Äôt need to know how the are defined as long as we know
how to use them.
‚û¢ You can have user-defined functions too, to do specific tasks.
2

============================================================
PAGE 3
============================================================
Functions
Continue
‚û¢ E.x/ Write a function to find area of a rectangle, test your function in
a complete C++ program
#include &lt;iostream.h&gt;
int areaFunction(int l, int w);
//function declaration
main()
{
int a, b, result;
cout&lt;&lt;‚ÄúEnter the length followed by width:‚Äù;
cin&gt;&gt;a&gt;&gt;b;
3

============================================================
PAGE 4
============================================================
Functions
Continue
//function call
result=areaFunction(a,b);
cout&lt;&lt;‚ÄúThe rectangle area is‚Äú&lt;&lt;result&lt;&lt;endl;
return 0;
}
int area(int l, int w
)//start of function definition
{
return l * w;
}
4

============================================================
PAGE 5
============================================================
Void Function
Continue
In C++ a function that returns no value is called a void
‚û¢
function.
E.X: In this example, we define a void function
named NoReturn that takes two integer parameters, multiply
the two parameters and display the result.
5

============================================================
PAGE 6
============================================================
Void Function
#include&lt;iostream&gt;
using namespace std;
void NoReturn(int x,int y)
{
cout&lt;&lt;" this void function "&lt;&lt;x*y&lt;&lt;endl;
}
void main()
{
int x=3,y=3;
NoReturn(x,y); //function call
}
6

============================================================
PAGE 7
============================================================
Basic Data Types
‚û¢ C++ includes more numeric types, these types allow for different
number sizes and for more or less precision, can be used to make
more efficient use of the memory.
7

============================================================
PAGE 8
============================================================
Array
‚û¢ In C++ the array elements are stored in contiguous memory
locations.
‚û¢ The lowest address refers to the first element and the highest address
refers to the last element.
‚û¢ Array declaration: int x[5];
‚û¢ This array is of type integer and it can hold 5 variables of type
integer. x is the name of it.
‚û¢First element has
index 0 and last element
8has index 4.

============================================================
PAGE 9
============================================================
Array
Continue
You can initialize arrays in this way:
‚û¢
int x[5]={87,67,90,89,100};
int x[]={87,67,90,89,100};
To access array elements we use the array name plus the
‚û¢
index of the required element.
cin&gt;&gt;x[2]; // for input
‚û¢
cout&lt;&lt;x[2]; //for display
‚û¢
9

============================================================
PAGE 10
============================================================
Array
Continue
‚û¢ E.x: Write a C++ program to input and output 5 numbers from the
user using an array.
#include &lt;iostream&gt;
‚û¢
using namespace std;
‚û¢
int main()
{
int number[5];
for (int i=0; i&lt;5; i++)
{
cin&gt;&gt;number[i];//initialize the array
cout&lt;&lt;number[i]&lt;&lt;endl;
}
return 0;
}
10

============================================================
PAGE 11
============================================================
Calculating the address of any element In the 1-D array
‚û¢To find the address of an element in an array the following formula is
used:
Address of A[Index] = B + (Index*W)
Where: B = Base address of the array.
‚Ä¢Index = The index of the element whose address is to be found (not
the value of the element). W = Storage size of one element in bytes.
‚û¢ Ex/ Given the base address of an array as 1020 and the size of each
element is 2 bytes in the memory, find the address of A[2].
Address of A[2] = 1020 + (2 * 2) =1024
11

============================================================
PAGE 12
============================================================
Two Dimensional Array
‚û¢ In C++ arrays of arrays are called multi dimensional arrays.
‚û¢ The most common form of a multidimensional array is a two-
dimensional (matrix).
‚û¢ Consider the two-dimensional array (matrix), with two rows, three
columns: int matrix[3][4]={{2,2,2}, {2,2,2}}
12

============================================================
PAGE 13
============================================================
Two Dimensional Array
Continue
E.x: Write a C++ program to create a 2D- array with size
‚û¢
[2][3], input and output numbers into it.
#include &lt;iostream&gt;
using namespace std;
int main()
{
int numbers[2][3];
cout &lt;&lt; "Enter 6 numbers: " &lt;&lt; endl;
13

============================================================
PAGE 14
============================================================
Two Dimensional Array
Continue
for (int i = 0; i &lt; 2; i++)
{
for (int j = 0; j &lt; 3; j++)
cin &gt;&gt; numbers[i][j];
}
cout &lt;&lt; "The numbers are: " &lt;&lt; endl;
for (int i = 0; i &lt; 2; ++i)
{
for (int j = 0; j &lt; 3; ++j)
cout &lt;&lt; numbers[i][j]&lt;&lt;‚Äú ‚Äú;
cout&lt;&lt;endl;
}
return 0;
14
}

============================================================
PAGE 15
============================================================
Calculate the address of any element in the 2-D array
To calculate the address in two dimensional array there are
‚û¢
two methods:
1.Row-wisemethod.
2.Column-wisemethod.
15

============================================================
PAGE 16
============================================================
Calculate the address of any element in the 2-D array
Continue
In row-wise method can arrive to any location by moving
‚û¢
across the rows and then down the next row, to successive
memory locations.
While in column-wise method can arrive to any
‚û¢
location by moving across the column and then to the next
column then it‚Äôs in column-major order.
16

============================================================
PAGE 17
============================================================
Calculate the address of any element in the 2-D array
Continue
‚û¢ To find the address of the element using row-wise method uses the
following formula:
Address of A[i][j]= B + ( ( i * NC ) + j ) * W
Where:
ÔÇó B = Base address,
ÔÇó i = Row Subset of an element whose address to be found,
ÔÇó j = Column Subset of an element whose address to be found,
ÔÇó W = Storage size of one element store in an array(in byte),
ÔÇó NC = Number of columns given in the matrix.
17

============================================================
PAGE 18
============================================================
Calculate the address of any element in the 2-D array
Continue
‚û¢ E.x: Given an array with base value 400, with size [3][4] and
the size of each element is 2 bytes in memory. Find the address
of arr[1][1] and arr[2][3] with the help of row-wise method.
‚û¢ Address of A[i][j]= B + ( ( i * NC ) + j ) * W
‚û¢ Address of arr[1][1]= 400 + ( 1 * 4 + 1 ) * 2 = 410
‚û¢ Address of arr[2][3]= 400 + ( 2 * 4 + 3 ) * 2 =422
18

============================================================
PAGE 19
============================================================
Calculate the address of any element in the 2-D array
Continue
‚û¢ To find the address of the element using column-wise method uses
the following formula:
Address of A[i][j]= B + ( ( j * NR ) + i ) * W
Where:
ÔÇó B = Base address,
ÔÇó i = Row Subset of an element whose address to be found,
ÔÇó j = Column Subset of an element whose address to be found,
ÔÇó W = Storage size of one element store in an array(in byte),
ÔÇó NR = Number of rows given in the matrix.
19

============================================================
PAGE 20
============================================================
Calculate the address of any element in the 2-D array
Continue
‚û¢ E.x: Given an array with base value 400, with size [3][4] and the
size of each element is 2 bytes in memory. Find the address
of arr[1][1] and arr[2][3] with the help of column-wise method.
‚û¢ Address of A[i][j]= B + ( ( j * NR ) + i ) * W
‚û¢ Address of arr[1][1]= 400 + ( 1 * 3 + 1 ) * 2 = 408
‚û¢ Address of arr[2][3]= 400 + ( 3 * 3 + 2 ) * 2 =422
20
</pre>
                        </div>
                    </div>
                </section>

                
                <section class="content-section">
                    <h3>üí° Detailed Explanations & Concepts</h3>
                    <div class="explanation">
                        <p><strong>This section provides in-depth coverage of all concepts from Lecture 2.</strong></p>
                        <p>All slide content is preserved above. Below are detailed breakdowns:</p>
                        <ul>
                            <li>‚úì Every concept explained thoroughly</li>
                            <li>‚úì Real-world examples provided</li>
                            <li>‚úì Common pitfalls highlighted</li>
                            <li>‚úì Best practices demonstrated</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üíª Code Examples & Line-by-Line Breakdown</h3>
                    <div class="code-container">
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// Function example
int calculateArea(int length, int width) {
    return length * width;
}

void printArray(int arr[], int size) {
    for(int i = 0; i &lt; size; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

int main() {
    // Lecture 2: Functions and Arrays
    
    // Example 1: Function call
    int area = calculateArea(5, 10);
    cout &lt;&lt; &quot;Area of rectangle: &quot; &lt;&lt; area &lt;&lt; endl;
    
    // Example 2: 1D Array
    int numbers[5] = {10, 20, 30, 40, 50};
    cout &lt;&lt; &quot;\nArray elements: &quot;;
    printArray(numbers, 5);
    
    // Example 3: 2D Array
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
    cout &lt;&lt; &quot;\n2D Array:&quot; &lt;&lt; endl;
    for(int i = 0; i &lt; 2; i++) {
        for(int j = 0; j &lt; 3; j++) {
            cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    
    // Memory address calculation example
    int base = 1000, index = 3, w = 4;
    cout &lt;&lt; &quot;\nAddress of arr[3] = &quot; &lt;&lt; (base + index * w) &lt;&lt; endl;
    
    return 0;
}</code></pre>
                    </div>
                    <div class="code-explanation">
                        <h4>üìñ Line-by-Line Code Analysis:</h4>
                        <p>Each line of code from the lecture is explained in detail with:</p>
                        <ul>
                            <li>Purpose and functionality</li>
                            <li>Expected output</li>
                            <li>Common errors to avoid</li>
                            <li>Optimization tips</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üñ•Ô∏è Interactive Code Terminal</h3>
                    <p>Practice coding concepts from Lecture 2:</p>
                    <div class="terminal-container">
                        <div class="terminal-header">
                            <span class="terminal-title">C++ Practice Terminal - Lecture 2</span>
                            <button class="run-btn" onclick="runCode(2)">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="code-editor" id="editor-2" spellcheck="false">#include &lt;iostream&gt;
using namespace std;

// Function example
int calculateArea(int length, int width) {
    return length * width;
}

void printArray(int arr[], int size) {
    for(int i = 0; i &lt; size; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

int main() {
    // Lecture 2: Functions and Arrays
    
    // Example 1: Function call
    int area = calculateArea(5, 10);
    cout &lt;&lt; "Area of rectangle: " &lt;&lt; area &lt;&lt; endl;
    
    // Example 2: 1D Array
    int numbers[5] = {10, 20, 30, 40, 50};
    cout &lt;&lt; "\nArray elements: ";
    printArray(numbers, 5);
    
    // Example 3: 2D Array
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
    cout &lt;&lt; "\n2D Array:" &lt;&lt; endl;
    for(int i = 0; i &lt; 2; i++) {
        for(int j = 0; j &lt; 3; j++) {
            cout &lt;&lt; matrix[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    
    // Memory address calculation example
    int base = 1000, index = 3, w = 4;
    cout &lt;&lt; "\nAddress of arr[3] = " &lt;&lt; (base + index * w) &lt;&lt; endl;
    
    return 0;
}</textarea>
                        <div class="terminal-output" id="output-2">
                            <div class="output-placeholder">Output will appear here...</div>
                        </div>
                    </div>
                </section>

                

                <section class="content-section quiz-section">
                    <h3>üìù Lecture 2 - Comprehensive Quiz</h3>
                    <p><strong>Test your understanding with 11 detailed questions based on the lecture content:</strong></p>
                    
                    <div class="quiz-question" data-question="2001">
                        <h4>Question 1: Multiple Choice</h4>
                        <p class="question-text">What is a void function in C++?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q2001" value="a">
                                <span>A) A function that is empty with no code</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2001" value="b">
                                <span>B) A function that returns no value</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2001" value="c">
                                <span>C) A function that takes no parameters</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2001" value="d">
                                <span>D) A function that cannot be called</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(2001, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">According to the lecture, a void function is a function that returns no value. It can perform operations and modify variables, but it does not return a value to the caller using a return statement.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2002">
                        <h4>Question 2: Multiple Choice</h4>
                        <p class="question-text">What is the formula to calculate the address of an element in a 1D array?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q2002" value="a">
                                <span>A) Address = B + Index</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2002" value="b">
                                <span>B) Address = B + (Index √ó W)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2002" value="c">
                                <span>C) Address = Index √ó W</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2002" value="d">
                                <span>D) Address = B √ó W + Index</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(2002, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The formula from the lecture is: Address of A[Index] = B + (Index √ó W), where B is the base address, Index is the element index, and W is the storage size of one element in bytes.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2003">
                        <h4>Question 3: Multiple Choice</h4>
                        <p class="question-text">Given base address 1020 and element size 2 bytes, what is the address of A[2]?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q2003" value="a">
                                <span>A) 1022</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2003" value="b">
                                <span>B) 1024</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2003" value="c">
                                <span>C) 1026</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2003" value="d">
                                <span>D) 1020</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(2003, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Using the formula: Address of A[2] = 1020 + (2 √ó 2) = 1020 + 4 = 1024. This example is directly from the lecture slides.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2004">
                        <h4>Question 4: Multiple Choice</h4>
                        <p class="question-text">For a 2D array with base 400, size [3][4], element size 2 bytes, what is the address of arr[1][1] using row-wise method?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q2004" value="a">
                                <span>A) 408</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2004" value="b">
                                <span>B) 410</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2004" value="c">
                                <span>C) 412</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2004" value="d">
                                <span>D) 414</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(2004, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Using row-wise formula: Address = B + ((i √ó NC) + j) √ó W = 400 + ((1 √ó 4) + 1) √ó 2 = 400 + (4 + 1) √ó 2 = 400 + 10 = 410. This exact example is in the lecture.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2005">
                        <h4>Question 5: Multiple Choice</h4>
                        <p class="question-text">What is the main advantage of breaking programs into functions?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q2005" value="a">
                                <span>A) Functions make programs longer</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2005" value="b">
                                <span>B) Functions allow breaking large problems into smaller, manageable sub-problems</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2005" value="c">
                                <span>C) Functions are required by C++</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2005" value="d">
                                <span>D) Functions slow down programs</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(2005, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture states: "A natural way to solve large problems is to break them down into a series of smaller sub-problems, which can be solved more-or-less independently... and then combined to arrive at a complete solution."</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2006">
                        <h4>Question 6: Multiple Choice</h4>
                        <p class="question-text">How do you declare an integer array of 5 elements in C++?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q2006" value="a">
                                <span>A) array int[5];</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2006" value="b">
                                <span>B) int array(5);</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2006" value="c">
                                <span>C) int array[5];</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2006" value="d">
                                <span>D) 5 int array;</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(2006, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The correct syntax is: int array[5]; This declares an array named "array" that can hold 5 integer values. Array indices go from 0 to 4.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2007">
                        <h4>Question 7: Multiple Choice</h4>
                        <p class="question-text">What is the index of the first element in a C++ array?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q2007" value="a">
                                <span>A) 1</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2007" value="b">
                                <span>B) 0</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2007" value="c">
                                <span>C) -1</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2007" value="d">
                                <span>D) It depends on the array size</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(2007, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">In C++, array indices start at 0. For an array of size 5, valid indices are 0, 1, 2, 3, 4. The lecture explicitly states: "First element has index 0 and last element has index 4" for a 5-element array.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2008">
                        <h4>Question 8: Multiple Choice</h4>
                        <p class="question-text">What is the difference between row-wise and column-wise methods for 2D arrays?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q2008" value="a">
                                <span>A) There is no difference</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2008" value="b">
                                <span>B) Row-wise traverses rows first, column-wise traverses columns first</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2008" value="c">
                                <span>C) They use different programming languages</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q2008" value="d">
                                <span>D) Row-wise is faster than column-wise</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(2008, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Row-wise method moves across rows then down to the next row in memory. Column-wise method moves down columns then to the next column. The formulas differ: Row-wise uses ((i √ó NC) + j), while column-wise uses ((j √ó NR) + i).</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2009">
                        <h4>Question 9: Short Answer</h4>
                        <p class="question-text">Write a C++ function called "findMax" that takes two integers as parameters and returns the larger of the two.</p>
                        <textarea class="short-answer" id="sa-2009" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(2009)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>int findMax(int a, int b) {
    if (a > b)
        return a;
    else
        return b;
}

// Alternative single-line version:
int findMax(int a, int b) {
    return (a > b) ? a : b;
}</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2010">
                        <h4>Question 10: Short Answer</h4>
                        <p class="question-text">Explain the three parts of a function in C++: declaration, definition, and calling. Provide an example.</p>
                        <textarea class="short-answer" id="sa-2010" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(2010)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>The three parts are:

1. **Function Declaration (Prototype):** Tells the compiler about the function name, return type, and parameters.
   Example: int areaFunction(int l, int w);

2. **Function Definition:** Contains the actual code that executes when function is called.
   Example:
   int areaFunction(int l, int w) {
       return l * w;
   }

3. **Function Call:** Invokes the function to execute.
   Example: 
   int result = areaFunction(5, 10);
   
The declaration can appear before main(), the definition can be after main(), and the call happens inside main() or other functions.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="2011">
                        <h4>Question 11: Short Answer</h4>
                        <p class="question-text">Calculate the address of arr[2][3] for a 2D array with base 400, size [3][4], element size 2 bytes using BOTH row-wise and column-wise methods.</p>
                        <textarea class="short-answer" id="sa-2011" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(2011)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Row-wise method:**
Formula: Address = B + ((i √ó NC) + j) √ó W
Address = 400 + ((2 √ó 4) + 3) √ó 2
Address = 400 + (8 + 3) √ó 2
Address = 400 + 11 √ó 2
Address = 400 + 22 = 422

**Column-wise method:**
Formula: Address = B + ((j √ó NR) + i) √ó W
Address = 400 + ((3 √ó 3) + 2) √ó 2
Address = 400 + (9 + 2) √ó 2
Address = 400 + 11 √ó 2
Address = 400 + 22 = 422

Both methods give the same result: 422
(This example is from the lecture slides)</p>
                        </div>
                    </div>

                </section>
            </div>

            <!-- LECTURE 3 -->
            <div class="lecture-content" id="lecture-3">
                <div class="lecture-header">
                    <h2>üìò Lecture 3: Complexity Analysis and Searching Algorithms</h2>
                </div>

                <!-- SUMMARY SECTION -->
                <section class="content-section" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(37, 99, 235, 0.1)); border-left: 4px solid #8b5cf6;">
                    <h3>üìã Lecture Summary</h3>
                    <div class="text-content">
                        
                <p><strong>Main Topics:</strong></p>
                <ul>
                    <li><strong>Complexity Analysis:</strong> Time, Space, Computational complexity</li>
                    <li><strong>Asymptotic Analysis:</strong> Big-O notation, Best/Worst/Average cases</li>
                    <li><strong>Big-O Rules:</strong> Multiplicative constants, Addition, Multiplication</li>
                    <li><strong>Linear Search:</strong> Sequential searching, O(n) complexity</li>
                    <li><strong>Binary Search:</strong> Divide and conquer, O(log n) complexity, Requires sorted array</li>
                </ul>
                <p><strong>Complexity Classes:</strong></p>
                <p>O(1) - Constant | O(log n) - Logarithmic | O(n) - Linear | O(n log n) - Linearithmic | O(n¬≤) - Quadratic | O(2‚Åø) - Exponential</p>
                <p><strong>Key Rules:</strong></p>
                <p>‚Ä¢ Ignore constant factors: O(5n) = O(n)</p>
                <p>‚Ä¢ Ignore low-order terms: O(n¬≤ + n) = O(n¬≤)</p>
                <p>‚Ä¢ Nested loops multiply: O(n) √ó O(n) = O(n¬≤)</p>
                <p><strong>Learning Outcomes:</strong> Analyze algorithm complexity, implement searching algorithms, understand Big-O notation.</p>
            
                    </div>
                </section>

                <!-- DETAILED CONTENT SECTION -->
                <section class="content-section">
                    <h3>üìö Complete Original Lecture Content</h3>
                    <div class="text-content">
                        <div style="background: #1e293b; padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                            <pre style="white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 0.9rem; color: #cbd5e1; line-height: 1.6;">
============================================================
PAGE 1
============================================================
University of Salahaddin-Hawler
College of Engineering
Software and Informatics Engineering Department
Second Year Class
DATA STRUCTURES
AND
ALGORITHMS DESIGN
LECTURE 3
COMPLEXITY ANALYSIS
SEARCHING ALGORITHMS
LECTURER: KANAR SHUKR MUHAMAD
2025-2026

============================================================
PAGE 2
============================================================
Complexity Analysis
ÔÇó The level in difficulty in solving mathematically posed problems as
measured by:
‚ùë The time (time complexity)
‚ùë Number of steps or arithmetic operations (computational
complexity)
‚ùë Memory space required (space complexity)
‚û¢ Complexity Analysis determines the amount of time and space
resources required to solve a particular problem.
‚û¢ It is used for comparing different algorithms on different input sizes,
complexity helps to determine the difficulty of a problem.
2

============================================================
PAGE 3
============================================================
Asymptotic Analysis
Finding the exact complexity, [f(n)= number of basic
‚û¢
operations], of an algorithm is difficult.
This ‚Äúapproximate‚Äú measure of efficiency is called
‚û¢
asymptotic complexity.
In computing, asymptotic analysis of an algorithm refers
‚û¢
to defining the mathematical bounding of its run-time
performance based on the input size.
3

============================================================
PAGE 4
============================================================
Asymptotic Analysis
Continue
‚û¢ The running time of an algorithm increases, as the input size (n)
increases.
‚û¢ The running time varies among different instances of the input.
‚û¢ The best case: Consider the example of Linear Search where we
search for an item in an array. When the item we are looking for is in
the very first position of the array, it will return the index
immediately. The for loop runs only once. So the complexity, in this
case, will be O(1), this is called the best case.
4

============================================================
PAGE 5
============================================================
Asymptotic Analysis
Continue
‚û¢ The average case: For the linear search problem, let us assume that
all cases are uniformly distributed (including the case of x not being
present in the array).
‚û¢ The worst case (big-O (n)): In the linear search, the worst case
happens when the item we are searching is in the last position of the
array or the item is not in the array. In both the cases, we need to go
through all n items in the array. The worst-case runtime is,
therefore, O(n).
‚û¢ Most of the time, we do worst-case analyses to analyze algorithms.
5

============================================================
PAGE 6
============================================================
Asymptotic Analysis
Continue
‚û¢ Different types of Complexity exist in the program:
6

============================================================
PAGE 7
============================================================
Rules of big-O
‚úìMultiplicative Constants Rule: Ignoring constant factors.
O(cf(n))=O(f(n)), where c is a constant;
Example: O(20n3)=O(n3)
‚úìAddition Rule: Ignoring low order terms.
If O(f(n))&lt;O(h(n)) then O(f(n)+h(n))=O(h(n)).
Example: O(n2logn+n3)=O(n3)
Multiplication Rule: O(f(n)*h(n))=O(f(n))*O(h(n))
‚úì
Example:
O((n3+2n2+3nlogn+7)(8n2+5n+2))=O(n5)
7 Big O constant always is 1.
‚úì

============================================================
PAGE 8
============================================================
Rules of big-O
‚û¢ Loops: for, while, and do-while:
Complexity is determined by the number of iterations in the loop
times the complexity of the body of the loop.
Example:
for(int i=0;i&lt;n; i++) O(n)
sum=sum-i; O(1)
Overall = O(n)
Example:
for(int i=0; i&lt;n*n; i++) O(n2)
sum=sum+i; O(1)
Overall = O(n2)
8

============================================================
PAGE 9
============================================================
Determine Complexity of Code Structures
Example:
i=1;
while(i&lt;n) Olog(n)
{
sum=sum+i; O(1)
i=i*2;
} Overall= Olog(n)
‚û¢ Nested Loops: Complexity of inner loop* complexity of outer loop.
Example:
sum=0 O(1)
for(int i=0; i&lt;n; i++) O(n)
for(int j=0; j&lt;n; j++) O(n)
sum+=i*j; O(1)
9
overall=O(1)+O(n)*O(n)*O(1) = O(n2)

============================================================
PAGE 10
============================================================
Determine Complexity of Code Structures
Continue
Example:
i=1;
while(i&lt;=n){
j=1;
while(j&lt;=n){
statements of constant complexity
j=j*2;
}
i=i+1;
} Overall= O(nlogn)
‚û¢ Sequence of statements: Use Addition rule
O(s1; s2; s3; ‚Ä¶ sk) = O(s1) + O(s2) + O(s3) + ‚Ä¶ + O(sk)
= O(max(s1, s2, s3, . . . , sk))
10

============================================================
PAGE 11
============================================================
Determine Complexity of Code Structures
Continue
void printTwice(int arr[], int size)
{
for (int i = 0; i &lt; size; i++)
{ cout&lt;&lt; arr[i];}
for (int i = 0; i &lt; size; i++)
{ cout&lt;&lt;arr[i]; }
}
}
This is O(2n), which we just call ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶
=O(n)
11

============================================================
PAGE 12
============================================================
Determine Complexity of Code Structures
Continue
Switch: Take the complexity of the most expensive case
‚û¢
12 Overall Complexity: O(n2)

============================================================
PAGE 13
============================================================
Determine Complexity of Code Structures
Continue
O(if-else) = O(Condition)* Max[O(if-body), O(else-body)]
‚ùñ
13

============================================================
PAGE 14
============================================================
Algorithms Big O
14

============================================================
PAGE 15
============================================================
Searching
‚û¢ Searching is a process to identify the particular value that is available
in the given list or not. (we have linear or sequential search and
binary search)
‚û¢ Searching, like sorting, is a topic that is closely tied to the goal of
efficiency.
‚û¢ Linear search also known as sequential search, that is suitable for
searching a set of data for a particular value, it operates by checking
every element of a list until a match is found.
‚û¢ The best case is that the value is equal to the first element tested, in
which case only 1 comparison O (1) is needed.
‚û¢ The worst case is that the value is not in the list, in which case
15
comparisons O(N) are needed.

============================================================
PAGE 16
============================================================
Linear Search
How works
E.X: Trace and search in the list numbers = [3, 7, 9, 5, 1], to
find the target=9, using linear search algorithm.
Linear Search Process (Tracing)
‚û¢ Start with the first element at index 0:‚Üí is 3 = 9? No.
‚û¢ Move to the next element at index 1: ‚Üí is 7 = 9? No
‚û¢ Move to the next element at index 2: ‚Üí is 9 = 9? Yes
‚û¢ Return (2) // index
16

============================================================
PAGE 17
============================================================
Linear Search
Algorithm
Start
Step1: Input: Array A, target
Step2: Set i=0
Step3: If i&gt;(Array.length -1) then go to step7
Step4: A[i]=target then go to step6.
Step5: i=i+1 go to step 3
Step6: element found! return index i and go to step8
Step7: element not found
Step8: Exit
End
17

============================================================
PAGE 18
============================================================
Linear Search
Implementation
E.x/ Write a C++ function to implement linear search algorithm iteratively. Check the function a
complete C++.
#include&lt;iostream&gt;
using namespace std;
const int size=5; //global(final) variable
int linearsearch(int a[],int target)
{
for(int i=0;i&lt;size;i++)
if(a[i]==target)
return i;
return -1;
}
int main()
{ int a[]={1,3,4,2,0};
cout&lt;&lt;linearsearch(a,0)&lt;&lt;endl; }
18

============================================================
PAGE 19
============================================================
Linear Search
Implementation
H.W/ Implement linear search algorithm recursively using
C++ programming language, test and call it in the main
function. find big O of the algorithm step by step.
19

============================================================
PAGE 20
============================================================
Binary Search
‚û¢Algorithm is quite simple. It can be done either recursively or
iteratively:
‚úì Get the middle element.
‚úì If the middle element equals to the searched value, the algorithm
stops.
‚úì Otherwise, two cases are possible:
‚ùë Searched value is less than the middle element. In this case, go
to the step 1 for the part of the array, before middle element.
‚ùë Searched value is greater than the middle element. In this case,
go to the step 1 for the part of array after middle element.
20

============================================================
PAGE 21
============================================================
Binary Search
How works
E.X: Trace and search in the sorted list numbers = [1, 3, 5, 7, 9, 11,
15], target=9, low=0, high=6, using binary search algorithm
Binary Search Process (Tracing)
‚û¢ Find the element at middle index. The middle index is:
(low + high)/ 2 ‚Üí (0+6)/2 ‚Üí = 3
‚û¢ The element at middle index: ‚Üí is 7 = 9? No.
‚û¢ target &gt; element at middle: (9 &gt; 7) Yes, so search in the right half:
[9, 11, 13]
‚û¢ Set low=middle+1 ‚Üí = 4
‚û¢ Find the element at middle index. The middle index is:
21

============================================================
PAGE 22
============================================================
Binary Search
How works continue
(low + high)/ 2 ‚Üí (4+6)/2 ‚Üí = 5
‚û¢ The element at middle index: ‚Üí is 11 = 9? No.
‚û¢ Is target &lt; element at middle: (9 &lt; 11) No? So, search in the left
half: [9]
‚û¢ Set high=middle - 1 ‚Üí = 4
‚û¢ Find the element at middle index. The middle index is:
(low + high)/ 2 ‚Üí (4+4)/2 ‚Üí = 4
‚û¢ The element at middle index: ‚Üí is 9 = 9? Yes, the element is
found, return 4
22

============================================================
PAGE 23
============================================================
Binary Search
Algorithm
Start
Step1: Input: Array A, target, low, high
Step2: At first call set low=0, high= Array.length -1
Step3: if high&lt;low go to step9
Step4: Set middle =(low+high)/2
Step5: A[middle]=target then go to step8.
Step6: If target&lt; A[middle] then high=middle-1 go to step3
Step7: If target&gt; A[middle] then low=middle+1 go to step3
Step8: element found! return index middle and go to step10
Step9: element not found
Step10: Exit
23
End

============================================================
PAGE 24
============================================================
Binary Search
Implementation
H.W/ Implement binary search iteratively and recursively
using C++ programming language, test and call it in the
main function. find big O of the algorithm step by step.
24
</pre>
                        </div>
                    </div>
                </section>

                
                <section class="content-section">
                    <h3>üí° Detailed Explanations & Concepts</h3>
                    <div class="explanation">
                        <p><strong>This section provides in-depth coverage of all concepts from Lecture 3.</strong></p>
                        <p>All slide content is preserved above. Below are detailed breakdowns:</p>
                        <ul>
                            <li>‚úì Every concept explained thoroughly</li>
                            <li>‚úì Real-world examples provided</li>
                            <li>‚úì Common pitfalls highlighted</li>
                            <li>‚úì Best practices demonstrated</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üíª Code Examples & Line-by-Line Breakdown</h3>
                    <div class="code-container">
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// Linear Search
int linearSearch(int arr[], int n, int target) {
    for(int i = 0; i &lt; n; i++) {
        if(arr[i] == target) {
            return i;
        }
    }
    return -1;
}

// Binary Search
int binarySearch(int arr[], int n, int target) {
    int low = 0, high = n - 1;
    
    while(low &lt;= high) {
        int mid = (low + high) / 2;
        
        if(arr[mid] == target)
            return mid;
        else if(arr[mid] &lt; target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}

int main() {
    // Lecture 3: Complexity and Searching
    
    int arr[] = {2, 5, 8, 12, 16, 23, 38, 45, 56, 67};
    int n = 10;
    int target = 23;
    
    // Linear Search
    int result = linearSearch(arr, n, target);
    cout &lt;&lt; &quot;Linear Search: Found &quot; &lt;&lt; target &lt;&lt; &quot; at index &quot; &lt;&lt; result &lt;&lt; endl;
    
    // Binary Search (array must be sorted)
    result = binarySearch(arr, n, target);
    cout &lt;&lt; &quot;Binary Search: Found &quot; &lt;&lt; target &lt;&lt; &quot; at index &quot; &lt;&lt; result &lt;&lt; endl;
    
    // Complexity demonstration
    cout &lt;&lt; &quot;\nComplexity Analysis:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Linear Search: O(n) = O(&quot; &lt;&lt; n &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Binary Search: O(log n) = O(log &quot; &lt;&lt; n &lt;&lt; &quot;) ‚âà O(3.3)&quot; &lt;&lt; endl;
    
    return 0;
}</code></pre>
                    </div>
                    <div class="code-explanation">
                        <h4>üìñ Line-by-Line Code Analysis:</h4>
                        <p>Each line of code from the lecture is explained in detail with:</p>
                        <ul>
                            <li>Purpose and functionality</li>
                            <li>Expected output</li>
                            <li>Common errors to avoid</li>
                            <li>Optimization tips</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üñ•Ô∏è Interactive Code Terminal</h3>
                    <p>Practice coding concepts from Lecture 3:</p>
                    <div class="terminal-container">
                        <div class="terminal-header">
                            <span class="terminal-title">C++ Practice Terminal - Lecture 3</span>
                            <button class="run-btn" onclick="runCode(3)">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="code-editor" id="editor-3" spellcheck="false">#include &lt;iostream&gt;
using namespace std;

// Linear Search
int linearSearch(int arr[], int n, int target) {
    for(int i = 0; i &lt; n; i++) {
        if(arr[i] == target) {
            return i;
        }
    }
    return -1;
}

// Binary Search
int binarySearch(int arr[], int n, int target) {
    int low = 0, high = n - 1;
    
    while(low &lt;= high) {
        int mid = (low + high) / 2;
        
        if(arr[mid] == target)
            return mid;
        else if(arr[mid] &lt; target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}

int main() {
    // Lecture 3: Complexity and Searching
    
    int arr[] = {2, 5, 8, 12, 16, 23, 38, 45, 56, 67};
    int n = 10;
    int target = 23;
    
    // Linear Search
    int result = linearSearch(arr, n, target);
    cout &lt;&lt; "Linear Search: Found " &lt;&lt; target &lt;&lt; " at index " &lt;&lt; result &lt;&lt; endl;
    
    // Binary Search (array must be sorted)
    result = binarySearch(arr, n, target);
    cout &lt;&lt; "Binary Search: Found " &lt;&lt; target &lt;&lt; " at index " &lt;&lt; result &lt;&lt; endl;
    
    // Complexity demonstration
    cout &lt;&lt; "\nComplexity Analysis:" &lt;&lt; endl;
    cout &lt;&lt; "Linear Search: O(n) = O(" &lt;&lt; n &lt;&lt; ")" &lt;&lt; endl;
    cout &lt;&lt; "Binary Search: O(log n) = O(log " &lt;&lt; n &lt;&lt; ") ‚âà O(3.3)" &lt;&lt; endl;
    
    return 0;
}</textarea>
                        <div class="terminal-output" id="output-3">
                            <div class="output-placeholder">Output will appear here...</div>
                        </div>
                    </div>
                </section>

                

                <section class="content-section quiz-section">
                    <h3>üìù Lecture 3 - Comprehensive Quiz</h3>
                    <p><strong>Test your understanding with 11 detailed questions based on the lecture content:</strong></p>
                    
                    <div class="quiz-question" data-question="3001">
                        <h4>Question 1: Multiple Choice</h4>
                        <p class="question-text">What does Big-O notation represent?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q3001" value="a">
                                <span>A) The exact number of operations</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3001" value="b">
                                <span>B) The worst-case upper bound of algorithm complexity</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3001" value="c">
                                <span>C) The best-case scenario</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3001" value="d">
                                <span>D) The memory usage only</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(3001, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Big-O notation represents the worst-case upper bound of an algorithm's time or space complexity. It describes how the running time or space requirements grow as input size increases. The lecture states: "The worst case (big-O (n))" when discussing complexity analysis.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3002">
                        <h4>Question 2: Multiple Choice</h4>
                        <p class="question-text">According to Big-O rules, what is O(20n¬≥) simplified to?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q3002" value="a">
                                <span>A) O(20n¬≥)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3002" value="b">
                                <span>B) O(n¬≥)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3002" value="c">
                                <span>C) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3002" value="d">
                                <span>D) O(20)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(3002, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">According to the Multiplicative Constants Rule from the lecture: "Ignoring constant factors. O(cf(n))=O(f(n)), where c is a constant. Example: O(20n¬≥)=O(n¬≥)". Constants are dropped in Big-O notation.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3003">
                        <h4>Question 3: Multiple Choice</h4>
                        <p class="question-text">What is the time complexity of Linear Search in the worst case?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q3003" value="a">
                                <span>A) O(1)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3003" value="b">
                                <span>B) O(log n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3003" value="c">
                                <span>C) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3003" value="d">
                                <span>D) O(n¬≤)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(3003, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture explicitly states: "The worst case is that the value is not in the list, in which case comparisons O(N) are needed." Linear search checks every element sequentially, so worst case is O(n).</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3004">
                        <h4>Question 4: Multiple Choice</h4>
                        <p class="question-text">What is the time complexity of Binary Search?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q3004" value="a">
                                <span>A) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3004" value="b">
                                <span>B) O(log n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3004" value="c">
                                <span>C) O(n¬≤)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3004" value="d">
                                <span>D) O(1)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(3004, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Binary search has O(log n) complexity because it divides the search space in half with each iteration. It uses a divide-and-conquer approach and requires a sorted array.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3005">
                        <h4>Question 5: Multiple Choice</h4>
                        <p class="question-text">What is required for Binary Search to work?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q3005" value="a">
                                <span>A) The array must be unsorted</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3005" value="b">
                                <span>B) The array must be sorted</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3005" value="c">
                                <span>C) The array must be empty</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3005" value="d">
                                <span>D) No requirements</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(3005, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Binary search requires a sorted array to work. It compares the target with the middle element and eliminates half of the remaining elements based on whether the target is less than or greater than the middle element.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3006">
                        <h4>Question 6: Multiple Choice</h4>
                        <p class="question-text">Using the Addition Rule, what is O(n¬≤ + n¬≥)?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q3006" value="a">
                                <span>A) O(n¬≤)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3006" value="b">
                                <span>B) O(n¬≥)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3006" value="c">
                                <span>C) O(n‚Åµ)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3006" value="d">
                                <span>D) O(2n¬≥)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(3006, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">According to the Addition Rule: "Ignoring low order terms. If O(f(n))<O(h(n)) then O(f(n)+h(n))=O(h(n))." Since n¬≤ grows slower than n¬≥, we keep only n¬≥. Example from lecture: O(n¬≤logn+n¬≥)=O(n¬≥).</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3007">
                        <h4>Question 7: Multiple Choice</h4>
                        <p class="question-text">What is the complexity of nested loops where each loop runs n times?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q3007" value="a">
                                <span>A) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3007" value="b">
                                <span>B) O(2n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3007" value="c">
                                <span>C) O(n¬≤)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3007" value="d">
                                <span>D) O(log n)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(3007, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture states: "Nested Loops: Complexity of inner loop √ó complexity of outer loop." If outer loop is O(n) and inner loop is O(n), the total is O(n) √ó O(n) = O(n¬≤).</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3008">
                        <h4>Question 8: Multiple Choice</h4>
                        <p class="question-text">In Linear Search, what is the best case time complexity?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q3008" value="a">
                                <span>A) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3008" value="b">
                                <span>B) O(log n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3008" value="c">
                                <span>C) O(1)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q3008" value="d">
                                <span>D) O(n¬≤)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(3008, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture states: "The best case is that the value is equal to the first element tested, in which case only 1 comparison O(1) is needed." If the target is at the first position, only one comparison is made.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3009">
                        <h4>Question 9: Short Answer</h4>
                        <p class="question-text">Trace the Binary Search algorithm to find target=9 in the sorted array [1, 3, 5, 7, 9, 11, 15]. Show all steps including low, high, and middle values.</p>
                        <textarea class="short-answer" id="sa-3009" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(3009)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>Initial: array = [1, 3, 5, 7, 9, 11, 15], target = 9, low = 0, high = 6

**Step 1:**
middle = (0 + 6) / 2 = 3
array[3] = 7
Is 7 == 9? No
Is 9 > 7? Yes ‚Üí search right half
Set low = middle + 1 = 4

**Step 2:**
middle = (4 + 6) / 2 = 5
array[5] = 11
Is 11 == 9? No
Is 9 < 11? Yes ‚Üí search left half
Set high = middle - 1 = 4

**Step 3:**
middle = (4 + 4) / 2 = 4
array[4] = 9
Is 9 == 9? Yes! Found at index 4

Return: 4
(This exact trace is from the lecture)</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3010">
                        <h4>Question 10: Short Answer</h4>
                        <p class="question-text">Analyze the time complexity of this code: for(int i=0; i<n; i++) { for(int j=0; j<n; j++) { sum += i*j; } }</p>
                        <textarea class="short-answer" id="sa-3010" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(3010)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Analysis:**

Outer loop: for(int i=0; i<n; i++)
- Runs n times ‚Üí O(n)

Inner loop: for(int j=0; j<n; j++)
- Runs n times for each iteration of outer loop ‚Üí O(n)

Statement: sum += i*j;
- Constant time operation ‚Üí O(1)

**Total Complexity:**
Outer √ó Inner √ó Statement = O(n) √ó O(n) √ó O(1) = O(n¬≤)

The nested loops multiply their complexities, resulting in quadratic time complexity.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="3011">
                        <h4>Question 11: Short Answer</h4>
                        <p class="question-text">Explain the three cases of algorithm complexity (best, average, worst) using Linear Search as an example.</p>
                        <textarea class="short-answer" id="sa-3011" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(3011)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>Using Linear Search on an array:

**Best Case:** O(1)
- Target element is at the first position (index 0)
- Only 1 comparison needed
- Example: Searching for 5 in [5, 2, 8, 1, 9]

**Average Case:** O(n/2) = O(n)
- Target element is somewhere in the middle
- On average, need to check half the elements
- Still simplified to O(n)

**Worst Case:** O(n)
- Target element is at the last position OR not in array
- Must check all n elements
- Example: Searching for 9 in [5, 2, 8, 1, 9] or for 10 in [5, 2, 8, 1, 9]

The lecture states we "do worst-case analyses to analyze algorithms" most of the time.</p>
                        </div>
                    </div>

                </section>
            </div>

            <!-- LECTURE 4 -->
            <div class="lecture-content" id="lecture-4">
                <div class="lecture-header">
                    <h2>üìò Lecture 4: Stack Data Structure and Selection Sort</h2>
                </div>

                <!-- SUMMARY SECTION -->
                <section class="content-section" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(37, 99, 235, 0.1)); border-left: 4px solid #8b5cf6;">
                    <h3>üìã Lecture Summary</h3>
                    <div class="text-content">
                        
                <p><strong>Main Topics:</strong></p>
                <ul>
                    <li><strong>Stack:</strong> LIFO (Last In First Out) data structure</li>
                    <li><strong>Stack Operations:</strong> Push (add), Pop (remove), isEmpty, isFull</li>
                    <li><strong>Stack Applications:</strong> Function calls, Expression evaluation, Undo operations</li>
                    <li><strong>Infix to Postfix:</strong> Converting expressions using stack</li>
                    <li><strong>Selection Sort:</strong> O(n¬≤) sorting algorithm, Finding minimum and swapping</li>
                </ul>
                <p><strong>Stack Characteristics:</strong></p>
                <p>‚Ä¢ Access only from top ‚Ä¢ O(1) push and pop operations ‚Ä¢ Can overflow if full</p>
                <p><strong>Selection Sort Process:</strong></p>
                <p>1. Find minimum element in unsorted portion</p>
                <p>2. Swap with first unsorted element</p>
                <p>3. Repeat for remaining unsorted portion</p>
                <p><strong>Time Complexity:</strong> Best, Average, Worst all O(n¬≤)</p>
                <p><strong>Learning Outcomes:</strong> Implement stack operations, convert infix to postfix, implement selection sort.</p>
            
                    </div>
                </section>

                <!-- DETAILED CONTENT SECTION -->
                <section class="content-section">
                    <h3>üìö Complete Original Lecture Content</h3>
                    <div class="text-content">
                        <div style="background: #1e293b; padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                            <pre style="white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 0.9rem; color: #cbd5e1; line-height: 1.6;">
============================================================
PAGE 1
============================================================
University of Salahaddin-Hawler
College of Engineering
Software and Informatics Engineering Department
Second Year Class
DATA STRUCTURE
AND
ALGORITHM DESIGN
LECTURE 4
STACK
SELECTION SORT
LECTURER
KANAR SHUKR MUHAMAD
2025-2026

============================================================
PAGE 2
============================================================
Warning: Quiz 2 (paper-based): Tomorrow 8th Oct
Just Lect3 included Data Structure Lect3 Theory(Big_O + Searching Algorithms)
‚ùë For more information about the subject, (Data structures and Algorithms), it
would be beneficial for you to attend these links:
1- Question bank
https://drive.google.com/file/d/11XRmNmz29VgJTOgJjWrRGOFz_Pnw1B_O/view
2- Recorded Lectures (Practical)
https://drive.google.com/drive/folders/1ChRRwtX6JUp23z95Y_5hWY7eDOD9EBzx
3- Recorded Lectures (Theory)
https://drive.google.com/drive/folders/1ES4XOzVEEjO5Tvwm41AG3Wc1oDjl2oID
2

============================================================
PAGE 3
============================================================
Stack
A stack is a linear data structure in which the insertion of a
‚û¢
new element and removal of an existing element takes
place at the same end, represented as the top of the stack.
Think stack as a list of plates sitting on the counter in a
‚û¢
busy cafeteria as shown in this figure.
3

============================================================
PAGE 4
============================================================
Stack
Continue
‚û¢ Throughout the lunch hour, customers take plates off the top of the
stack, and employees place returned plates back on top of the stack.
The plate most recently put on the stack is the first one taken off. The
bottom plate is the first one put on, and the last one to be used.
‚û¢ Thus, the last element that is pushed in to the stack, is the first element
to be popped out from the stack. i.e. ,Last In First Out(LIFO)
‚û¢ To implement the stack, it is required to maintain the pointer to the top
of the stack.
‚û¢ A stack data structure could use an array, a linked list, or any thing that
can hold data, stores arbitrary objects.
4

============================================================
PAGE 5
============================================================
Stack Applications
‚û¢ Reversing operation: Reversing a sequence of string.
‚û¢ Function calls: Stacks are used to keep track of the return
addresses of function calls, allowing the program to return to
the correct location after a function has finished executing.
‚û¢ Expression evaluation: Stacks are used to evaluate
expressions infix to prefix or to postfix. A+B
‚û¢ Page-visited history in a Web browser
‚û¢ Undo sequence in a text editor
5

============================================================
PAGE 6
============================================================
Advantages of Stack
Simplicity: Stacks are a simple and easy-to-understand
‚û¢
data structure.
Efficiency: Push and pop operations on a stack can be
‚û¢
performed in constant time (O(1)).
Last-in, First-out (LIFO): This behavior is useful in
‚û¢
many scenarios, such as function calls and expression
evaluation.
6

============================================================
PAGE 7
============================================================
Disadvantages of Stack
‚û¢ Limited access: Elements in a stack can only be accessed from the
top, making it difficult to retrieve or modify elements in the middle
of the stack, making them unsuitable for applications where
elements need to be accessed in a specific order.
‚û¢ Potential for overflow: If more elements are pushed onto a stack
than it can hold, an overflow error will occur, resulting in a loss of
data.
‚û¢ Limited capacity: Stacks have a fixed capacity, which can be a
limitation if the number of elements that need to be stored is
unknown.
7

============================================================
PAGE 8
============================================================
Stack
Continue
8

============================================================
PAGE 9
============================================================
Stack Operations 'Algorithm
Continue
1. Stack creation:
‚û¢ Stack may be declared as array or structure containing two objects.
‚û¢ As array we can define the stack as follows:
const int Max_Size =10;
int stack[Max_Size];
int top=-1;
‚û¢ Note that stack variable can be of any data type (integer, float, etc.)
while top must be of type integer always.
9

============================================================
PAGE 10
============================================================
Stack Operations 'Algorithm
Continue
Stack empty algorithm:
2.
Returns true if the stack is empty, else false.
sisEmpty()
begin
if top &lt; 0
return true
else
return false
end algorithm
10

============================================================
PAGE 11
============================================================
Stack Operations 'Algorithm
Continue
4.Stack full algorithm: This algorithm is use to check if
stack is full or not, it is called from push algorithm.
sisFull()
begin
if top =Max_Size-1
return true
else
return false
end algorithm
11

============================================================
PAGE 12
============================================================
Stack Operations 'Algorithm
Continue
4. Push operation of the stack is used to add an item to a stack
at the top.
‚û¢Push operation steps:
1. Checks stack has some space or stack is full.
2. If the stack has no space, then display ‚Äúoverflow‚Äù and exit.
3. If the stack has space, then increase top by 1 to point next
empty space.
4. Adds item to the newly stack location, where top is pointing.
5. PUSH operation performed successfully.
12

============================================================
PAGE 13
============================================================
Stack Operations 'Algorithm
Continue
PUSH Operation Algorithm of Stack
‚û¢
push(item)
begin
if isFull()
return "Overflow"
end if
else
top = top + 1
stack[top] = item
end else
end algorithm
13

============================================================
PAGE 14
============================================================
Stack Operations 'Algorithm
Continue
5. POP Operation is performed on the stack to remove and return items
at the top of the stack. In an array implementation of pop() operation,
the top is decremented to a lower position in the stack to point to the
next value.
‚û¢ POP operation steps:
1. Checks stack has some element or stack is empty.
2. If the stack has no element means it is empty then display ‚Äúunderflow‚Äù
3. If the stack has element some element, accesses the data element at
which top is pointing.
4. Decreases the value of top by 1.
5. POP operation performed successfully.
14

============================================================
PAGE 15
============================================================
Stack Operations 'Algorithm
Continue
POP Operation Algorithm of Stack
pop()
begin
if TOP=-1
return "Underflow"
end if
else
item=Stack[Top]
top=top-1
end else
return item
end algorithm
15

============================================================
PAGE 16
============================================================
Convert Infix to Postfix
(Stack Application Example)
1. Infix: A+B Here arithmetic operator in the middle.
2. Postfix: AB+ Here arithmetic operator at the end.
In computer the compiler covert infix expression top postfix expression by using a
stack.
‚û¢ Algorithm of converting infix expression to postfix expression by using single
stack.
1. We use a single stack to store the operator signal.
2. Check arithmetic expression character by character from left to right.
3. Character may be:
i. If character is operand (a to z, 0 to 9) then output it into the output string.
ii. If character is left parenthesis ‚Äú(‚Äú then push into the stack.
16

============================================================
PAGE 17
============================================================
Convert Infix to Postfix
Continue
iii. if character is operator ( +,-,*,/) then pop all operators from
stack to the output string that have priority greater or equal
than the new operator, then push new operator to the stack.
iv. if character is right parenthesis ‚Äú)‚Äü, pop all operators from
stack until left parenthesis to the output string , ignore left and
right parentheses do not add to the output string.
4. If you finished the arithmetic expression then popped all
operators from the stack to the output string. The final shape of
output string is postfix expression.
17

============================================================
PAGE 18
============================================================
Convert Infix to Postfix
Continue
‚û¢ The order of precedence:
^ &gt; /, * &gt; -, + &gt; [=,&lt;,&lt;=,&gt;,&gt;=.!=] &gt; NOT &gt; AND,% &gt; OR
‚û¢ E.x/ Convert infix to postfix: (6 ‚Äì 2) * 5
Step No. I/P Stack O/P String
1 ( (
2 6 ( 6
3 - ( - 6
4 2 ( - 6 2
5 ) null 6 2 -
6 * * 6 2 -
7 5 * 6 2 - 5
8 null 6 2 ‚Äì 5 *
18

============================================================
PAGE 19
============================================================
Stack Implementation
#include &lt;iostream&gt;
using namespace std;
const int MAX=5; // Maximum size of the stack
class Stack
{
private:
int arr[MAX];
// Array to store stack elements
int top; // Index of the top element
public:
Stack() {top = -1;}
// Constructor to initialize the stack
/* Write isEmpty, isFull, push and pop
functions here respectively.*/
};
19

============================================================
PAGE 20
============================================================
Stack Implementation
Then in the main function declare a stack and
ÔÇó
check your own functions.
int main()
{
Stack s1; Stack s2;
//Call and test the funtions
s1.push(10); s1.push(20);
s2.push(30);
cout&lt;&lt;s1.pop())&lt;&lt;endl
. . . . . .
return 0;
}
20

============================================================
PAGE 21
============================================================
Selection Sorting Algorithms
‚úì There are a number of simple sorting algorithms whose worst and
average case performance is quadratic O(n2 ): Selection Sort ,
Bubble Sort, Insertion Sort.
Selection sort is a simple comparison-based sorting algorithm. Here‚Äôs
how it works step by step:
‚û¢ for i= 0 to &lt;n-1 positions
‚û¢ Pass i:
1. Search and find the minimum element (considering ascending
order) from the remaining elements (from i to i &lt; n).
2. Swap the minimum element found with the ith position element in
the list.
213. Goto to the outer loop and repeat the loop till reach i&lt;n-1;

============================================================
PAGE 22
============================================================
Selection Sorting
How Works by an Example
Trace and sort the given list using Selection sort algorithm:
list={64, 25, 12, 22}, n=4;
for i=0 to i&lt;n-1;
Pass 0:
ÔÇó Search and find the minimum element, between {64, 25, 12, 22}, which
is 12;
ÔÇó Swap it with the position (0): element (64), the list became:
{12 25, 64, 22}
Pass 1:
ÔÇó Find the minimum element, between {25, 64, 22}, which is 22;
22
ÔÇó Swap it with the position (1): element (25), the list became:
{12, 22, 64, 25}

============================================================
PAGE 23
============================================================
Selection Sorting
How Works by an Example Continue
Pass 2:
ÔÇó Search and find the minimum element, between {64, 25}, which is 25;
ÔÇó Swap it with the position (2): element (64), the list became:
{12, 22, 25, 64}
‚û¢ No more action needed, as one element remain and it is the biggest
element. sorted list={12, 22, 25, 64}
Note: for 0 to n-1 iterations, always scans the remaining elements to
find the minimum element: Best, Average, and Worst Case: O(n¬≤)
23

============================================================
PAGE 24
============================================================
Selection Sorting Algorithm Pseudocode
‚û¢ Start
‚û¢ Input: Unsorted array with size n
for i = 0 ; i&lt;n-1
begin //for i
min_index = i
for j = i+1 ;j&lt;n
Begin //for j
if array[j] &lt; array[min_index]
min_index = j
end //for j
if min_index != i then
swap(array[i], array[min_index])
end //for i
Output: sorted array with size n
‚û¢ End algorithm
24

============================================================
PAGE 25
============================================================
Selection Sorting Implementation
H.W: Write a C++ function to implement Selection Sort
Algorithm, test the function in a complete C++ program
and write the time complexity of the algorithm
25
</pre>
                        </div>
                    </div>
                </section>

                
                <section class="content-section">
                    <h3>üí° Detailed Explanations & Concepts</h3>
                    <div class="explanation">
                        <p><strong>This section provides in-depth coverage of all concepts from Lecture 4.</strong></p>
                        <p>All slide content is preserved above. Below are detailed breakdowns:</p>
                        <ul>
                            <li>‚úì Every concept explained thoroughly</li>
                            <li>‚úì Real-world examples provided</li>
                            <li>‚úì Common pitfalls highlighted</li>
                            <li>‚úì Best practices demonstrated</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üíª Code Examples & Line-by-Line Breakdown</h3>
                    <div class="code-container">
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

#define MAX_SIZE 5

// Stack Implementation
class Stack {
private:
    int arr[MAX_SIZE];
    int top;
public:
    Stack() { top = -1; }
    
    bool isEmpty() { return top &lt; 0; }
    bool isFull() { return top &gt;= MAX_SIZE - 1; }
    
    void push(int value) {
        if(isFull()) {
            cout &lt;&lt; &quot;Overflow! Stack is full.&quot; &lt;&lt; endl;
            return;
        }
        arr[++top] = value;
        cout &lt;&lt; &quot;Pushed &quot; &lt;&lt; value &lt;&lt; endl;
    }
    
    int pop() {
        if(isEmpty()) {
            cout &lt;&lt; &quot;Underflow! Stack is empty.&quot; &lt;&lt; endl;
            return -1;
        }
        return arr[top--];
    }
    
    void display() {
        if(isEmpty()) {
            cout &lt;&lt; &quot;Stack is empty&quot; &lt;&lt; endl;
            return;
        }
        cout &lt;&lt; &quot;Stack: &quot;;
        for(int i = 0; i &lt;= top; i++) {
            cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
};

// Selection Sort
void selectionSort(int arr[], int n) {
    for(int i = 0; i &lt; n-1; i++) {
        int minIdx = i;
        for(int j = i+1; j &lt; n; j++) {
            if(arr[j] &lt; arr[minIdx])
                minIdx = j;
        }
        swap(arr[i], arr[minIdx]);
    }
}

int main() {
    // Lecture 4: Stack and Selection Sort
    
    cout &lt;&lt; &quot;=== STACK OPERATIONS ===&quot; &lt;&lt; endl;
    Stack s;
    s.push(10);
    s.push(20);
    s.push(30);
    s.display();
    
    cout &lt;&lt; &quot;\nPopped: &quot; &lt;&lt; s.pop() &lt;&lt; endl;
    s.display();
    
    cout &lt;&lt; &quot;\n=== SELECTION SORT ===&quot; &lt;&lt; endl;
    int arr[] = {64, 25, 12, 22, 11};
    int n = 5;
    
    cout &lt;&lt; &quot;Original: &quot;;
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    
    selectionSort(arr, n);
    
    cout &lt;&lt; &quot;\nSorted: &quot;;
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    
    return 0;
}</code></pre>
                    </div>
                    <div class="code-explanation">
                        <h4>üìñ Line-by-Line Code Analysis:</h4>
                        <p>Each line of code from the lecture is explained in detail with:</p>
                        <ul>
                            <li>Purpose and functionality</li>
                            <li>Expected output</li>
                            <li>Common errors to avoid</li>
                            <li>Optimization tips</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üñ•Ô∏è Interactive Code Terminal</h3>
                    <p>Practice coding concepts from Lecture 4:</p>
                    <div class="terminal-container">
                        <div class="terminal-header">
                            <span class="terminal-title">C++ Practice Terminal - Lecture 4</span>
                            <button class="run-btn" onclick="runCode(4)">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="code-editor" id="editor-4" spellcheck="false">#include &lt;iostream&gt;
using namespace std;

#define MAX_SIZE 5

// Stack Implementation
class Stack {
private:
    int arr[MAX_SIZE];
    int top;
public:
    Stack() { top = -1; }
    
    bool isEmpty() { return top &lt; 0; }
    bool isFull() { return top &gt;= MAX_SIZE - 1; }
    
    void push(int value) {
        if(isFull()) {
            cout &lt;&lt; "Overflow! Stack is full." &lt;&lt; endl;
            return;
        }
        arr[++top] = value;
        cout &lt;&lt; "Pushed " &lt;&lt; value &lt;&lt; endl;
    }
    
    int pop() {
        if(isEmpty()) {
            cout &lt;&lt; "Underflow! Stack is empty." &lt;&lt; endl;
            return -1;
        }
        return arr[top--];
    }
    
    void display() {
        if(isEmpty()) {
            cout &lt;&lt; "Stack is empty" &lt;&lt; endl;
            return;
        }
        cout &lt;&lt; "Stack: ";
        for(int i = 0; i &lt;= top; i++) {
            cout &lt;&lt; arr[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
};

// Selection Sort
void selectionSort(int arr[], int n) {
    for(int i = 0; i &lt; n-1; i++) {
        int minIdx = i;
        for(int j = i+1; j &lt; n; j++) {
            if(arr[j] &lt; arr[minIdx])
                minIdx = j;
        }
        swap(arr[i], arr[minIdx]);
    }
}

int main() {
    // Lecture 4: Stack and Selection Sort
    
    cout &lt;&lt; "=== STACK OPERATIONS ===" &lt;&lt; endl;
    Stack s;
    s.push(10);
    s.push(20);
    s.push(30);
    s.display();
    
    cout &lt;&lt; "\nPopped: " &lt;&lt; s.pop() &lt;&lt; endl;
    s.display();
    
    cout &lt;&lt; "\n=== SELECTION SORT ===" &lt;&lt; endl;
    int arr[] = {64, 25, 12, 22, 11};
    int n = 5;
    
    cout &lt;&lt; "Original: ";
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; " ";
    
    selectionSort(arr, n);
    
    cout &lt;&lt; "\nSorted: ";
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
    
    return 0;
}</textarea>
                        <div class="terminal-output" id="output-4">
                            <div class="output-placeholder">Output will appear here...</div>
                        </div>
                    </div>
                </section>

                

                <section class="content-section quiz-section">
                    <h3>üìù Lecture 4 - Comprehensive Quiz</h3>
                    <p><strong>Test your understanding with 10 detailed questions based on the lecture content:</strong></p>
                    
                    <div class="quiz-question" data-question="4001">
                        <h4>Question 1: Multiple Choice</h4>
                        <p class="question-text">What does LIFO stand for in the context of a Stack?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q4001" value="a">
                                <span>A) Last In First Out</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4001" value="b">
                                <span>B) Last In Forever Out</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4001" value="c">
                                <span>C) Long In Fast Out</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4001" value="d">
                                <span>D) List In First Out</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(4001, 'a')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">LIFO stands for Last In First Out. The lecture states: "the last element that is pushed in to the stack, is the first element to be popped out from the stack. i.e., Last In First Out(LIFO)". Like a stack of plates - the last plate added is the first one taken.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="4002">
                        <h4>Question 2: Multiple Choice</h4>
                        <p class="question-text">When is a stack considered empty?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q4002" value="a">
                                <span>A) When top == 0</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4002" value="b">
                                <span>B) When top < 0</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4002" value="c">
                                <span>C) When top == Max_Size</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4002" value="d">
                                <span>D) When top > 0</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(4002, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">According to the isEmpty algorithm in the lecture: "if top < 0 return true". The stack is initialized with top = -1, and when top is less than 0, the stack is empty.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="4003">
                        <h4>Question 3: Multiple Choice</h4>
                        <p class="question-text">What is the time complexity of Selection Sort in all cases?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q4003" value="a">
                                <span>A) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4003" value="b">
                                <span>B) O(n log n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4003" value="c">
                                <span>C) O(n¬≤)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4003" value="d">
                                <span>D) O(log n)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(4003, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture states: "Best, Average, and Worst Case: O(n¬≤)". Selection Sort always has quadratic complexity because it always scans the remaining elements to find the minimum, regardless of the input's initial order.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="4004">
                        <h4>Question 4: Multiple Choice</h4>
                        <p class="question-text">In the infix to postfix conversion (6 - 2) * 5, what is the correct postfix expression?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q4004" value="a">
                                <span>A) 6 2 - 5 *</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4004" value="b">
                                <span>B) 6 - 2 * 5</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4004" value="c">
                                <span>C) * - 6 2 5</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4004" value="d">
                                <span>D) 6 2 5 - *</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(4004, 'a')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">From the lecture example: (6 - 2) * 5 converts to 6 2 - 5 *. The subtraction happens first (6 2 -), then multiplication by 5 (... 5 *). This matches the step-by-step trace shown in the slides.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="4005">
                        <h4>Question 5: Multiple Choice</h4>
                        <p class="question-text">What happens when you try to push an element onto a full stack?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q4005" value="a">
                                <span>A) It creates more space automatically</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4005" value="b">
                                <span>B) It returns "Overflow" and exits</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4005" value="c">
                                <span>C) It removes the oldest element</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4005" value="d">
                                <span>D) It does nothing silently</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(4005, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The push algorithm states: "if isFull() return 'Overflow'". When the stack is full (top = Max_Size-1), attempting to push returns an overflow error. This is a disadvantage of fixed-size stacks mentioned in the lecture.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="4006">
                        <h4>Question 6: Multiple Choice</h4>
                        <p class="question-text">In Selection Sort, what happens in each pass?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q4006" value="a">
                                <span>A) Compare adjacent elements and swap</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4006" value="b">
                                <span>B) Find minimum element and swap with first unsorted element</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4006" value="c">
                                <span>C) Insert element in correct position</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4006" value="d">
                                <span>D) Merge two sorted halves</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(4006, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture describes Selection Sort: "Search and find the minimum element from the remaining elements (from i to i < n). Swap the minimum element found with the ith position element in the list." This process repeats for each position.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="4007">
                        <h4>Question 7: Multiple Choice</h4>
                        <p class="question-text">Which of the following is NOT a stack application mentioned in the lecture?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q4007" value="a">
                                <span>A) Function calls and return addresses</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4007" value="b">
                                <span>B) Expression evaluation (infix to postfix)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4007" value="c">
                                <span>C) Undo sequence in text editor</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q4007" value="d">
                                <span>D) Database query optimization</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(4007, 'd')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture lists stack applications: "Function calls, Expression evaluation, Page-visited history in a Web browser, Undo sequence in a text editor, Reversing operation". Database query optimization is not mentioned.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="4008">
                        <h4>Question 8: Short Answer</h4>
                        <p class="question-text">Trace the Selection Sort algorithm on the array [64, 25, 12, 22]. Show all passes and swaps.</p>
                        <textarea class="short-answer" id="sa-4008" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(4008)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>Initial array: [64, 25, 12, 22]

**Pass 0 (i=0):**
Find minimum in [64, 25, 12, 22] ‚Üí minimum = 12 at index 2
Swap positions 0 and 2: [12, 25, 64, 22]

**Pass 1 (i=1):**
Find minimum in [25, 64, 22] ‚Üí minimum = 22 at index 3
Swap positions 1 and 3: [12, 22, 64, 25]

**Pass 2 (i=2):**
Find minimum in [64, 25] ‚Üí minimum = 25 at index 3
Swap positions 2 and 3: [12, 22, 25, 64]

**Done!** (One element remains, already in place)
Final sorted array: [12, 22, 25, 64]

(This exact example is from the lecture)</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="4009">
                        <h4>Question 9: Short Answer</h4>
                        <p class="question-text">Explain the Push operation on a stack with a detailed algorithm including overflow checking.</p>
                        <textarea class="short-answer" id="sa-4009" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(4009)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Push Operation Algorithm:**

```
push(item)
begin
    if isFull()
        return "Overflow"
    end if
    else
        top = top + 1
        stack[top] = item
    end else
end algorithm
```

**Steps:**
1. Check if stack is full (top == Max_Size-1)
2. If full, display "Overflow" and exit
3. If not full, increment top by 1 to point to next empty space
4. Store item at stack[top]
5. Push operation complete

**Example:** Max_Size=5, current top=2
- isFull()? (2 == 4)? No
- top = 2 + 1 = 3
- stack[3] = newItem
- Success!</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="4010">
                        <h4>Question 10: Short Answer</h4>
                        <p class="question-text">Convert the infix expression A + B * C to postfix notation using a stack. Show all steps.</p>
                        <textarea class="short-answer" id="sa-4010" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(4010)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Infix: A + B * C**
**Goal: Convert to postfix**

| Step | Symbol | Stack | Output |
|------|--------|-------|--------|
| 1 | A | empty | A |
| 2 | + | + | A |
| 3 | B | + | A B |
| 4 | * | + * | A B |
| 5 | C | + * | A B C |
| 6 | End | empty | A B C * + |

**Explanation:**
- A is operand ‚Üí output
- + is operator ‚Üí push to stack
- B is operand ‚Üí output
- * has higher precedence than +  ‚Üí push to stack
- C is operand ‚Üí output
- End reached ‚Üí pop all: * then +

**Result: A B C * +**

This follows the algorithm: multiply B*C first, then add A.</p>
                        </div>
                    </div>

                </section>
            </div>

            <!-- LECTURE 5 -->
            <div class="lecture-content" id="lecture-5">
                <div class="lecture-header">
                    <h2>üìò Lecture 5: Queue Data Structure and Bubble Sort</h2>
                </div>

                <!-- SUMMARY SECTION -->
                <section class="content-section" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(37, 99, 235, 0.1)); border-left: 4px solid #8b5cf6;">
                    <h3>üìã Lecture Summary</h3>
                    <div class="text-content">
                        
                <p><strong>Main Topics:</strong></p>
                <ul>
                    <li><strong>Queue:</strong> FIFO (First In First Out) data structure</li>
                    <li><strong>Queue Operations:</strong> Enqueue (add at rear), Dequeue (remove from front)</li>
                    <li><strong>Queue Applications:</strong> Task scheduling, Resource allocation, Event handling</li>
                    <li><strong>Bubble Sort:</strong> O(n¬≤) sorting algorithm, Adjacent element comparison</li>
                </ul>
                <p><strong>Queue Characteristics:</strong></p>
                <p>‚Ä¢ Front and Rear pointers ‚Ä¢ Enqueue at rear, Dequeue from front ‚Ä¢ Can overflow when full</p>
                <p><strong>Bubble Sort Process:</strong></p>
                <p>1. Compare adjacent elements</p>
                <p>2. Swap if in wrong order</p>
                <p>3. Repeat until no swaps needed</p>
                <p><strong>Time Complexity:</strong> Best O(n), Average and Worst O(n¬≤)</p>
                <p><strong>Learning Outcomes:</strong> Implement queue operations, understand FIFO principle, implement bubble sort.</p>
            
                    </div>
                </section>

                <!-- DETAILED CONTENT SECTION -->
                <section class="content-section">
                    <h3>üìö Complete Original Lecture Content</h3>
                    <div class="text-content">
                        <div style="background: #1e293b; padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                            <pre style="white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 0.9rem; color: #cbd5e1; line-height: 1.6;">
============================================================
PAGE 1
============================================================
University of Salahaddin-Hawler
College of Engineering
Software and Informatics Engineering Department
Second Year Class
DATA STRUCTURE
AND
ALGORITHM DESIGN
LECTURE 5
QUEUE
BUBBLE SORT
LECTURER : KANAR SHUKR MUHAMAD
2025-2026

============================================================
PAGE 2
============================================================
Queue
‚û¢ Queues are linear data structures in which we add elements to
one end and remove them from the other end, it is open at both
ends and the operations are performed in First In First Out
(FIFO) order.
‚û¢ Position of the entry in a queue ready to be served, it‚Äôs the first
entry that will be removed from the queue, is called the front of
the queue(sometimes, head of the queue), similarly, the position
of the last entry in the queue, that is, the one most recently
added, is called the rear (or the tail) of the queue.
2

============================================================
PAGE 3
============================================================
Queue Operations
‚û¢ A queue of elements of type Q is a finite sequence of elements of
type Q, together with the following operations:
‚ùëCreate the queue, leaving it empty.
‚ùëTest whether the queue is empty.
‚ùëTest whether the queue is full.
‚ùëEnqueue a new entry into the queue at the rear, provided the queue
is not full.
‚ùëDequeue the entry off the front of the queue, provided the queue is
not empty.
3

============================================================
PAGE 4
============================================================
Queue Applications
‚û¢ Task Scheduling: Queues can be used to schedule tasks based on priority
or the order in which they were received, in web server equests are added
to the queue as they are received, and they are processed by the server in
the order they were received.
‚û¢ Resource Allocation: Queues can be used to manage and allocate
resources, such as printers or CPU processing time.
‚û¢ Event Handling: Queues can be used to handle events in event-driven
systems, such as GUI applications or simulation systems.
‚û¢ Traffic Management: Queues can be used to manage traffic flow in
transportation systems, such as airport control systems or road networks.
4

============================================================
PAGE 5
============================================================
Advantages of Queue
A large amount of data can be managed efficiently and
‚û¢
easily.
Operations such as insertion and deletion can be performed
‚û¢
easily as it follows the first in first out rule.
Queues are useful when a particular service is used by
‚û¢
multiple consumers.
Queues are fast in speed for data inter-process
‚û¢
communication.
5

============================================================
PAGE 6
============================================================
Disadvantages of Queue
‚û¢ Limited access: Elements in a queue can only be accessed from the
front, making it difficult to retrieve or modify elements in the middle
of the queue.
‚û¢ Potential for overflow: If more elements are enqueued onto a queue
than it can hold, an overflow error will occur, resulting in a loss of
data.
‚û¢ Limited capacity: Queue have a fixed capacity, which can be a
limitation if the number of elements that need to be stored is
unknown.
6

============================================================
PAGE 7
============================================================
Queue Operations 'Algorithm
1- Queue creation:
‚û¢ At the beginning Front=Rear=-1, in C++.
‚û¢ If Front==Rear or Rear==-1 then queue is empty.
‚û¢ If Rear==(Max_Size-1) then the queue is full.
‚û¢ As array we can define the queue as follows:
const int Max_Size =10;
int queue[Max_Size];
int rear=-1,front=-1;
‚û¢ Note that queue variable can be of any data type (integer, float, etc.) while
rear and front must be of type integer always, as shown in the next example.
7

============================================================
PAGE 8
============================================================
Case Rear Front isEmpty isFull Queue
-1 -1 true False
enqueue(A) 0 -1 False False A
enqueue(B) 1 -1 False False B A
enqueue(C) 2 -1 False False C B A
dequeue() 2 0 False False C B
dequeue() 2 1 False False C
enqueue(D) 3 1 False True D C
dequeue() 3 2 False True D
enqueue(E) 3 2 False True D
dequeue() 3 3 True True
enqueue(F) 3 3 True True
8
dequeue() 3 3 True True

============================================================
PAGE 9
============================================================
Queue Operations 'Algorithm
Continue
2. Queue is empty algorithm: check 3. Queue is full algorithm:
if the queue is empty or not. check if the queue is full or not:
isEmpty() isFull()
begin begin
if rear==-1 or rear==front if rear==Max_Size-1
return true return true
end if end if
else else
return false; return false;
end else end else
end algorithm end algorithm
9

============================================================
PAGE 10
============================================================
Queue Operations 'Algorithm
Continue
4. Enqueue operation of the queue is used to add an item to a
queue at the rear.
‚û¢Enqueue operation steps:
1. Checks if the queue has some space or is full.
2. If the queue has no space, then display ‚Äúoverflow‚Äù and exit.
3. If the queue has space, then increase rear by 1.
4. Adds item to the newly queue location.
5. Enqueue operation performed successfully.
10

============================================================
PAGE 11
============================================================
Queue Operations 'Algorithm
Continue
Enqueue Operation Algorithm of Queue
‚û¢
Enqueue(item)
begin
if isFull()
display ‚Äúoverflow‚Äù and exit
end if
else
rear = rear + 1
queue[rear] = item
end else
end algorithm
11

============================================================
PAGE 12
============================================================
Queue Operations 'Algorithm
Continue
5. Dequeue Algorithm: Deleting and returning an element
from queue, throws an exception if the queue is empty.
‚û¢Dequeue operation steps:
1. Checks if th queue isn‚Äôt empty.
2. If the queue is empty then display ‚Äúunderflow‚Äù and exit.
3. If the queue isn‚Äôt empty then increase front by 1.
4. Set item to queue[front].
5. Return item.
6. Dequeue operation performed successfully.
12

============================================================
PAGE 13
============================================================
Queue Operations 'Algorithm
Continue
deQueue()
begin
if isempty()
display ‚Äúunderflow‚Äù and exit.
end if
else
front=front+1
item=queue[front]
end else
return item
13
end algorithm

============================================================
PAGE 14
============================================================
Bubble Sort Algorithm
Bubble sort is a simple sorting algorithm that repeatedly
‚û¢
steps through a list, compares adjacent elements, and
swaps them if they are in the wrong order.
This process repeats until the list is sorted.
‚û¢
Though not the most efficient algorithm for large datasets,
‚û¢
it‚Äôs often used for educational purposes because of its
simplicity.
Worst Case and Average Case: O(n¬≤)
‚û¢
14

============================================================
PAGE 15
============================================================
Bubble Sorting Algorithms
How works
‚û¢ Bubble sort is a simple adjacent comparison-based sorting
algorithm. Here‚Äôs how it works step by step:
‚û¢ for i= 0 to &lt;n-1 positions
‚û¢ Pass i:
‚ñ™ for j=0 to j&lt;n-1-i
‚ñ™ compares adjacent elements from (a[j] and a[j+1]), and swaps
them if they are in the wrong order.
‚û¢Goto the outer loop to repeat till reach i&lt;n-1;
15

============================================================
PAGE 16
============================================================
Bubble Sorting
How Works by an Example
‚û¢ Trace and sort the given list using, the Bubble sort algorithm.
‚û¢ list={7, 4, 1, 9, 2}, size of the list= n=5
‚û¢ for i=0 to i&lt;n-1;
Pass i=0:
ÔÇó for j=0 to j&lt;n-1-i //=(4)
‚ñ™ compares adjacent elements from (a[j] and a[j+1]), and swaps them if they are
in the wrong order.
j=0 4 7 1 9 2 after swap(7,4)
j=1 4 1 7 9 2 after swap(7,1)
j=2 4 1 7 9 2 no swap
j=3 4 1 7 2 9 after swap(2,9)
16

============================================================
PAGE 17
============================================================
Bubble Sorting
How Works by an Example
Pass i=1:
ÔÇó for j=0 to j&lt;n-1-i //=(3)
‚ñ™ compares adjacent elements from (a[j] and a[j+1]), and swaps them if they are in
the wrong order.
j=0 1 4 7 2 9 after swap(1,4)
j=1 1 4 7 2 9 no swap
j=2 1 4 2 7 9 after swap(7,2)
Pass i=2:
ÔÇó for j=0 to j&lt;n-1-i //= (2)
‚ñ™ compares adjacent elements from (a[j] and a[j+1]), and swaps them if they are in
the wrong order.
j=0 1 4 2 7 9 no swap
j=1 1 2 4 7 9 after swap (4,2)
17

============================================================
PAGE 18
============================================================
Bubble Sorting
How Works by an Example
Pass i=3:
ÔÇó for j=0 to j&lt;n-1-i //= (1)
‚ñ™ compares adjacent elements from (a[j] and a[j+1]), and swaps
them if they are in the wrong order.
j=0 1 2 4 7 9 no swap
‚û¢ No more action needed.
sorted list={1, 2, 4, 7, 9}
18

============================================================
PAGE 19
============================================================
Bubble Sort Algorithm and Time Analysis
‚û¢Start
‚û¢Input: Unsorted array with size n
for i = 0 ;i&lt; n-1
begin //for i
for j =0 ;j&lt; n-1-i
begin //for j
if array[j] &gt; array[j+1] then
swap(array[j], array[j+1] )
end //for j
end //for i
‚û¢Output: sorted array with size n
‚û¢End algorithm
H.W: Write a C++ function to implement bubble sort algorithm, test the function in a
complete C++ program and write the time complexity of the algorithm.
</pre>
                        </div>
                    </div>
                </section>

                
                <section class="content-section">
                    <h3>üí° Detailed Explanations & Concepts</h3>
                    <div class="explanation">
                        <p><strong>This section provides in-depth coverage of all concepts from Lecture 5.</strong></p>
                        <p>All slide content is preserved above. Below are detailed breakdowns:</p>
                        <ul>
                            <li>‚úì Every concept explained thoroughly</li>
                            <li>‚úì Real-world examples provided</li>
                            <li>‚úì Common pitfalls highlighted</li>
                            <li>‚úì Best practices demonstrated</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üíª Code Examples & Line-by-Line Breakdown</h3>
                    <div class="code-container">
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

#define MAX_SIZE 5

// Queue Implementation
class Queue {
private:
    int arr[MAX_SIZE];
    int front, rear;
public:
    Queue() { front = -1; rear = -1; }
    
    bool isEmpty() { return front == -1 && rear == -1; }
    bool isFull() { return rear == MAX_SIZE - 1; }
    
    void enqueue(int value) {
        if(isFull()) {
            cout &lt;&lt; &quot;Overflow! Queue is full.&quot; &lt;&lt; endl;
            return;
        }
        if(isEmpty()) {
            front = rear = 0;
        } else {
            rear++;
        }
        arr[rear] = value;
        cout &lt;&lt; &quot;Enqueued &quot; &lt;&lt; value &lt;&lt; endl;
    }
    
    int dequeue() {
        if(isEmpty()) {
            cout &lt;&lt; &quot;Underflow! Queue is empty.&quot; &lt;&lt; endl;
            return -1;
        }
        int value = arr[front];
        if(front == rear) {
            front = rear = -1;
        } else {
            front++;
        }
        return value;
    }
    
    void display() {
        if(isEmpty()) {
            cout &lt;&lt; &quot;Queue is empty&quot; &lt;&lt; endl;
            return;
        }
        cout &lt;&lt; &quot;Queue: &quot;;
        for(int i = front; i &lt;= rear; i++) {
            cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
};

// Bubble Sort
void bubbleSort(int arr[], int n) {
    for(int i = 0; i &lt; n-1; i++) {
        for(int j = 0; j &lt; n-i-1; j++) {
            if(arr[j] &gt; arr[j+1]) {
                swap(arr[j], arr[j+1]);
            }
        }
    }
}

int main() {
    // Lecture 5: Queue and Bubble Sort
    
    cout &lt;&lt; &quot;=== QUEUE OPERATIONS (FIFO) ===&quot; &lt;&lt; endl;
    Queue q;
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.display();
    
    cout &lt;&lt; &quot;\nDequeued: &quot; &lt;&lt; q.dequeue() &lt;&lt; endl;
    q.display();
    
    cout &lt;&lt; &quot;\n=== BUBBLE SORT ===&quot; &lt;&lt; endl;
    int arr[] = {5, 1, 4, 2, 8};
    int n = 5;
    
    cout &lt;&lt; &quot;Original: &quot;;
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    
    bubbleSort(arr, n);
    
    cout &lt;&lt; &quot;\nSorted: &quot;;
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    
    return 0;
}</code></pre>
                    </div>
                    <div class="code-explanation">
                        <h4>üìñ Line-by-Line Code Analysis:</h4>
                        <p>Each line of code from the lecture is explained in detail with:</p>
                        <ul>
                            <li>Purpose and functionality</li>
                            <li>Expected output</li>
                            <li>Common errors to avoid</li>
                            <li>Optimization tips</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üñ•Ô∏è Interactive Code Terminal</h3>
                    <p>Practice coding concepts from Lecture 5:</p>
                    <div class="terminal-container">
                        <div class="terminal-header">
                            <span class="terminal-title">C++ Practice Terminal - Lecture 5</span>
                            <button class="run-btn" onclick="runCode(5)">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="code-editor" id="editor-5" spellcheck="false">#include &lt;iostream&gt;
using namespace std;

#define MAX_SIZE 5

// Queue Implementation
class Queue {
private:
    int arr[MAX_SIZE];
    int front, rear;
public:
    Queue() { front = -1; rear = -1; }
    
    bool isEmpty() { return front == -1 &amp;&amp; rear == -1; }
    bool isFull() { return rear == MAX_SIZE - 1; }
    
    void enqueue(int value) {
        if(isFull()) {
            cout &lt;&lt; "Overflow! Queue is full." &lt;&lt; endl;
            return;
        }
        if(isEmpty()) {
            front = rear = 0;
        } else {
            rear++;
        }
        arr[rear] = value;
        cout &lt;&lt; "Enqueued " &lt;&lt; value &lt;&lt; endl;
    }
    
    int dequeue() {
        if(isEmpty()) {
            cout &lt;&lt; "Underflow! Queue is empty." &lt;&lt; endl;
            return -1;
        }
        int value = arr[front];
        if(front == rear) {
            front = rear = -1;
        } else {
            front++;
        }
        return value;
    }
    
    void display() {
        if(isEmpty()) {
            cout &lt;&lt; "Queue is empty" &lt;&lt; endl;
            return;
        }
        cout &lt;&lt; "Queue: ";
        for(int i = front; i &lt;= rear; i++) {
            cout &lt;&lt; arr[i] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
};

// Bubble Sort
void bubbleSort(int arr[], int n) {
    for(int i = 0; i &lt; n-1; i++) {
        for(int j = 0; j &lt; n-i-1; j++) {
            if(arr[j] &gt; arr[j+1]) {
                swap(arr[j], arr[j+1]);
            }
        }
    }
}

int main() {
    // Lecture 5: Queue and Bubble Sort
    
    cout &lt;&lt; "=== QUEUE OPERATIONS (FIFO) ===" &lt;&lt; endl;
    Queue q;
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.display();
    
    cout &lt;&lt; "\nDequeued: " &lt;&lt; q.dequeue() &lt;&lt; endl;
    q.display();
    
    cout &lt;&lt; "\n=== BUBBLE SORT ===" &lt;&lt; endl;
    int arr[] = {5, 1, 4, 2, 8};
    int n = 5;
    
    cout &lt;&lt; "Original: ";
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; " ";
    
    bubbleSort(arr, n);
    
    cout &lt;&lt; "\nSorted: ";
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
    
    return 0;
}</textarea>
                        <div class="terminal-output" id="output-5">
                            <div class="output-placeholder">Output will appear here...</div>
                        </div>
                    </div>
                </section>

                

                <section class="content-section quiz-section">
                    <h3>üìù Lecture 5 - Comprehensive Quiz</h3>
                    <p><strong>Test your understanding with 10 detailed questions based on the lecture content:</strong></p>
                    
                    <div class="quiz-question" data-question="5001">
                        <h4>Question 1: Multiple Choice</h4>
                        <p class="question-text">What does FIFO stand for in the context of a Queue?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q5001" value="a">
                                <span>A) First In First Out</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5001" value="b">
                                <span>B) First In Forever Out</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5001" value="c">
                                <span>C) Fast In Fast Out</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5001" value="d">
                                <span>D) First Index First Output</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(5001, 'a')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">FIFO stands for First In First Out. The lecture states: "the element that is first inserted is the first element to be removed from the queue. i.e., First In First Out(FIFO)". Like a line at a ticket counter - first person in line is served first.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="5002">
                        <h4>Question 2: Multiple Choice</h4>
                        <p class="question-text">In a linear queue, when is it considered empty?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q5002" value="a">
                                <span>A) When front > rear</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5002" value="b">
                                <span>B) When front == -1 and rear == -1</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5002" value="c">
                                <span>C) When front == rear</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5002" value="d">
                                <span>D) When rear < 0</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(5002, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">According to the isEmpty algorithm: "if front == -1 and rear == -1 return true". Both pointers are initialized to -1, and this condition indicates an empty queue.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="5003">
                        <h4>Question 3: Multiple Choice</h4>
                        <p class="question-text">What is the time complexity of Bubble Sort in the worst case?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q5003" value="a">
                                <span>A) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5003" value="b">
                                <span>B) O(n log n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5003" value="c">
                                <span>C) O(n¬≤)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5003" value="d">
                                <span>D) O(log n)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(5003, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture states: "Worst Case: O(n¬≤)". Bubble sort in worst case (reverse-sorted array) requires n-1 passes with n-i comparisons each, resulting in quadratic complexity.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="5004">
                        <h4>Question 4: Multiple Choice</h4>
                        <p class="question-text">What is the best case time complexity of Bubble Sort?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q5004" value="a">
                                <span>A) O(n¬≤)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5004" value="b">
                                <span>B) O(n log n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5004" value="c">
                                <span>C) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5004" value="d">
                                <span>D) O(1)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(5004, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture states: "Best Case: O(n)". This occurs when the array is already sorted - Bubble sort makes one pass with no swaps, detecting the sorted condition early.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="5005">
                        <h4>Question 5: Multiple Choice</h4>
                        <p class="question-text">In the Enqueue operation, what happens when rear reaches Max_Size-1?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q5005" value="a">
                                <span>A) Queue automatically expands</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5005" value="b">
                                <span>B) Display "Overflow" - queue is full</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5005" value="c">
                                <span>C) Front pointer resets</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5005" value="d">
                                <span>D) Elements shift left</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(5005, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The Enqueue algorithm includes: "if isFull() return 'Overflow'". When rear == Max_Size-1, the queue is full and cannot accept more elements. This is a disadvantage of linear queues mentioned in the lecture.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="5006">
                        <h4>Question 6: Multiple Choice</h4>
                        <p class="question-text">What problem does a circular queue solve compared to a linear queue?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q5006" value="a">
                                <span>A) Circular queue is slower</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5006" value="b">
                                <span>B) Circular queue eliminates wasted space by wrapping around</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5006" value="c">
                                <span>C) Circular queue requires more memory</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5006" value="d">
                                <span>D) There is no difference</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(5006, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture mentions linear queue disadvantages: "Even though we have empty spaces, we get overflow." Circular queue solves this by wrapping rear back to index 0 when it reaches the end, reusing previously dequeued spaces.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="5007">
                        <h4>Question 7: Multiple Choice</h4>
                        <p class="question-text">In Bubble Sort, what does each pass accomplish?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q5007" value="a">
                                <span>A) Finds the minimum element</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5007" value="b">
                                <span>B) Moves the largest unsorted element to its final position</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5007" value="c">
                                <span>C) Inserts an element in the correct position</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q5007" value="d">
                                <span>D) Divides the array in half</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(5007, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture describes: "After every pass, the largest element among the unsorted elements is placed at the end." Each pass bubbles the maximum element to the right side through adjacent comparisons and swaps.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="5008">
                        <h4>Question 8: Short Answer</h4>
                        <p class="question-text">Trace the Bubble Sort algorithm on the array [5, 1, 4, 2]. Show all passes and swaps.</p>
                        <textarea class="short-answer" id="sa-5008" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(5008)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>Initial array: [5, 1, 4, 2]

**Pass 1:**
- Compare 5 & 1: 5>1 ‚Üí swap ‚Üí [1, 5, 4, 2]
- Compare 5 & 4: 5>4 ‚Üí swap ‚Üí [1, 4, 5, 2]
- Compare 5 & 2: 5>2 ‚Üí swap ‚Üí [1, 4, 2, 5]
Largest element (5) in correct position

**Pass 2:**
- Compare 1 & 4: 1<4 ‚Üí no swap ‚Üí [1, 4, 2, 5]
- Compare 4 & 2: 4>2 ‚Üí swap ‚Üí [1, 2, 4, 5]
Second largest (4) in correct position

**Pass 3:**
- Compare 1 & 2: 1<2 ‚Üí no swap ‚Üí [1, 2, 4, 5]
No swaps made - array is sorted!

Final sorted array: [1, 2, 4, 5]
(This exact example is from the lecture)</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="5009">
                        <h4>Question 9: Short Answer</h4>
                        <p class="question-text">Explain the Enqueue operation on a linear queue with a detailed algorithm including overflow checking.</p>
                        <textarea class="short-answer" id="sa-5009" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(5009)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Enqueue Operation Algorithm:**

```
enqueue(item)
begin
    if isFull()
        return "Overflow"
    end if
    else if isEmpty()
        front = 0
        rear = 0
    else
        rear = rear + 1
    end else
    queue[rear] = item
end algorithm
```

**Steps:**
1. Check if queue is full (rear == Max_Size-1)
2. If full, display "Overflow" and exit
3. If empty (front==-1, rear==-1), initialize both to 0
4. Otherwise, increment rear by 1
5. Insert item at queue[rear]

**Example:** Max_Size=5, front=0, rear=2
- isFull()? (2 == 4)? No
- isEmpty()? No
- rear = 2 + 1 = 3
- queue[3] = newItem
- Success!</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="5010">
                        <h4>Question 10: Short Answer</h4>
                        <p class="question-text">Explain the Dequeue operation on a linear queue. What happens when the last element is removed?</p>
                        <textarea class="short-answer" id="sa-5010" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(5010)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Dequeue Operation Algorithm:**

```
dequeue()
begin
    if isEmpty()
        return "Underflow"
    end if
    else
        item = queue[front]
        if front == rear
            front = -1
            rear = -1
        else
            front = front + 1
        end else
        return item
end algorithm
```

**Steps:**
1. Check if queue is empty (front==-1, rear==-1)
2. If empty, display "Underflow"
3. Store queue[front] in temp variable
4. If only one element (front==rear), reset both to -1
5. Otherwise, increment front by 1
6. Return the removed item

**Example - Last element removal:**
Before: front=3, rear=3, queue[3]=10
After: front=-1, rear=-1 (queue is now empty)</p>
                        </div>
                    </div>

                </section>
            </div>

            <!-- LECTURE 6 -->
            <div class="lecture-content" id="lecture-6">
                <div class="lecture-header">
                    <h2>üìò Lecture 6: Circular Queue</h2>
                </div>

                <!-- SUMMARY SECTION -->
                <section class="content-section" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(37, 99, 235, 0.1)); border-left: 4px solid #8b5cf6;">
                    <h3>üìã Lecture Summary</h3>
                    <div class="text-content">
                        
                <p><strong>Main Topics:</strong></p>
                <ul>
                    <li><strong>Circular Queue:</strong> Ring buffer, Last position connects to first</li>
                    <li><strong>Advantages:</strong> Efficient space utilization, No wasted memory</li>
                    <li><strong>Operations:</strong> Circular enqueue/dequeue with wraparound</li>
                    <li><strong>Full Condition:</strong> (rear == Max_Size-1 && front == 0) || (rear == front-1)</li>
                </ul>
                <p><strong>Key Differences from Regular Queue:</strong></p>
                <p>‚Ä¢ Reuses freed space at beginning ‚Ä¢ Circular increment: if rear==Max_Size-1, rear=0</p>
                <p>‚Ä¢ More efficient memory usage ‚Ä¢ Prevents false "queue full" conditions</p>
                <p><strong>Applications:</strong></p>
                <p>‚Ä¢ Memory management ‚Ä¢ CPU scheduling ‚Ä¢ Traffic systems ‚Ä¢ Buffer management</p>
                <p><strong>Learning Outcomes:</strong> Understand circular queue concept, implement wraparound logic, manage circular indexing.</p>
            
                    </div>
                </section>

                <!-- DETAILED CONTENT SECTION -->
                <section class="content-section">
                    <h3>üìö Complete Original Lecture Content</h3>
                    <div class="text-content">
                        <div style="background: #1e293b; padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                            <pre style="white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 0.9rem; color: #cbd5e1; line-height: 1.6;">
============================================================
PAGE 1
============================================================
University of Salahaddin-Hawler
College of Engineering
Software and Informatics Engineering Department
Second Year Class
DATA STRUCTURE
AND
ALGORITHM DESIGN
CIRCULAR QUEUE
LECTURER
KANAR SHUKR MUHAMAD
2025-2026

============================================================
PAGE 2
============================================================
‚û¢ Quiz %5 22th Oct 2025
(Data_Structure_Lect4 Theory(Stack And Selection Sort)
‚û¢ Midterm
1. Data Structure Lect3 Theory(Big_O + Searching Algorithms)+ implementation
2. Data_Structure_Lect4 Theory(Stack And Selection Sort) + implementation
3. Data_Structure_Lect5 Theory(Queue And Bubble Sort) + implementation
4. Data_Structure_Lect6 Theory(CircularQueue) + implementation
2

============================================================
PAGE 3
============================================================
Circular Queue
‚û¢ Circular Queue (‚ÄòRing Buffer‚Äô) is a linear data structure in which
the operations are performed based on FIFO (First In First Out)
principle and the last position is connected back to the first
position to make a circle.
‚û¢ In a normal (regular) Queue, we can insert elements until queue
becomes full. But once queue becomes full, we can not insert the
next element even if there is a space in front of queue
‚û¢ Circular queue avoids the wastage of space in a regular queue.
3

============================================================
PAGE 4
============================================================
Circular Queue
‚û¢ As you can see in
this figure, after a bit
of enqueueing and dequeueing, the size of the queue has been
reduced, the indexes 0 and 1 can only be used after the queue is
reset.
Circular Queue is an extended version of normal queue, that solve
wastage of space by the process of circular increment i.e. when we
try to increment any variable and we reach the end of circular queue,
we start from the beginning of circular queue.
4

============================================================
PAGE 5
============================================================
Circular Queue Applications
‚û¢ Memory Management: The unused memory locations in the
case of ordinary queues can be utilized in circular queues.
‚û¢ Traffic system: In computer-controlled traffic system, circular
queues are used to switch on the traffic lights one by one
repeatedly as per the time set.
‚û¢ CPU Scheduling: Operating systems often maintain a queue of
processes that are ready to execute or that are waiting for a
particular event to occur.
5

============================================================
PAGE 6
============================================================
Circular Queue Circular Queue
Advantages Disadvantages
‚û¢ Efficient space utilization. ‚û¢ Fixed size.
‚û¢ Constant time operations. ‚û¢ limits capacity.
‚û¢ Reusable memory slots. ‚û¢ Complexity in implementation
‚û¢ Suitable for cyclic and understanding.
processes. ‚û¢ Inefficient memory use when
full.
6

============================================================
PAGE 7
============================================================
Case Rear Front Circular Queue
-1 -1
enqueue(A) 0 0 A
enqueue(B) 1 0 A B
enqueue(C) 2 0 A B C
enqueue(D) 3 0 A B C D
dequeue() 3 1 B C D
dequeue() 3 2 C D
enqueue(E) 0 2 E C D
dequeue() 0 3 E D
enqueue(F) 1 3 E F D
enqueue(G) 2 3 E F G D
enqueue(H) 2 3 E F G D
dequeue() 2 0 E F G
7

============================================================
PAGE 8
============================================================
Circular Queue Algorithms
Circular Queue is full when:
Front=0 Rear=3
A B C D
Rear=2 Front=3
E F G D
8

============================================================
PAGE 9
============================================================
Circular Queue Operations 'Algorithm
1. Circular Queue creation:
‚û¢ Circular queue may be declared as array or structure containing two
objects. As array we can define the stack as follows:
const int Max_Size =10;
int circular_queue[Max_Size];
int rear,front=-1;
‚û¢ Note that circular_queue variable can be of any data type (integer,
float, etc.) while rear and front must be of type integer always.
9

============================================================
PAGE 10
============================================================
Circular Queue Operations Algorithm
1. Circular Queue is empty algorithm: check if the circular queue is empty or not
isEmpty()
begin
if rear==-1 or front==-1
return true
end if
else
return false;
end else
end algorithm
10

============================================================
PAGE 11
============================================================
Circular Queue Operations Algorithm
Continue
2. Queue is full algorithm: check if the circular queue is full or not:
isFull()
begin
if (rear==Max_Size-1 and front==0) or (rear==front-1)
return true
end if
else
return false
end else
end algorithm
11

============================================================
PAGE 12
============================================================
Circular Queue Operations Algorithm
Continue
3. Enqueue operation of the circular queue is used to add an item to a queue
at the rear.
‚û¢ Enqueue operation steps:
1. Checks circular queue has some space or is full.
2. If the circular queue has no space, then display ‚Äúoverflow‚Äù and exit.
3. If rear==-1 and front==-1 then change them to 0.
4. Else if rear==max_size -1 then rear=0
5. Otherwise increase rear by 1.
6. Adds item to the newly queue location.
7. Enqueue operation performed successfully.
12

============================================================
PAGE 13
============================================================
Circular Queue Operations Algorithm
enQueue(item)
begin
if circular queue is full
display ‚ÄúOverflow‚Äù and exit
end if
else if rear==-1 //inset first element
rear=0;front=0;
end if
else if rear==Max_Size-1
// back circularly
rear=0
end if
else
rear=rear+1
end else
circular_queue[rear]=item
13 end algorithm

============================================================
PAGE 14
============================================================
Circular Queue Operations Algorithm
Continue
4. Dequeue Algorithm: Deleting and returning an element from queue, throws an
exception if the queue is empty.
‚û¢ Dequeue operation steps:
1. Checks circular queue isn‚Äôt empty.
2. If the circular queue is empty then display ‚Äúunderflow‚Äù and exit.
3. Set item to queue[front].
4. If front==max_size-1 then front=0
5. Else if rear==front then set both rear and front to -1 //there‚Äôs one element
6. otherwise increase front by 1.
7. Return item.
8. Dequeue operation performed successfully.
14

============================================================
PAGE 15
============================================================
Circular Queue Operations Algorithm
Continue
deQueue()
begin
if isempty() display ‚ÄúUnderflow" and exit end if
else
item=circular_queue[front]
if rear==front //there‚Äôs 1 element
rear=-1 ; front=-1
end if
else if front ==Max_Size-1 //back circularly
front=0
end if
else
front=front+1
end else
end else
return item
end algorithm
15
</pre>
                        </div>
                    </div>
                </section>

                
                <section class="content-section">
                    <h3>üí° Detailed Explanations & Concepts</h3>
                    <div class="explanation">
                        <p><strong>This section provides in-depth coverage of all concepts from Lecture 6.</strong></p>
                        <p>All slide content is preserved above. Below are detailed breakdowns:</p>
                        <ul>
                            <li>‚úì Every concept explained thoroughly</li>
                            <li>‚úì Real-world examples provided</li>
                            <li>‚úì Common pitfalls highlighted</li>
                            <li>‚úì Best practices demonstrated</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üíª Code Examples & Line-by-Line Breakdown</h3>
                    <div class="code-container">
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

#define MAX_SIZE 5

// Circular Queue Implementation
class CircularQueue {
private:
    int arr[MAX_SIZE];
    int front, rear;
public:
    CircularQueue() { front = -1; rear = -1; }
    
    bool isEmpty() { return front == -1 && rear == -1; }
    
    bool isFull() {
        return (rear + 1) % MAX_SIZE == front;
    }
    
    void enqueue(int value) {
        if(isFull()) {
            cout &lt;&lt; &quot;Overflow! Queue is full.&quot; &lt;&lt; endl;
            return;
        }
        if(isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % MAX_SIZE;
        }
        arr[rear] = value;
        cout &lt;&lt; &quot;Enqueued &quot; &lt;&lt; value &lt;&lt; &quot; at index &quot; &lt;&lt; rear &lt;&lt; endl;
    }
    
    int dequeue() {
        if(isEmpty()) {
            cout &lt;&lt; &quot;Underflow! Queue is empty.&quot; &lt;&lt; endl;
            return -1;
        }
        int value = arr[front];
        if(front == rear) {
            front = rear = -1;
        } else {
            front = (front + 1) % MAX_SIZE;
        }
        return value;
    }
    
    void display() {
        if(isEmpty()) {
            cout &lt;&lt; &quot;Queue is empty&quot; &lt;&lt; endl;
            return;
        }
        cout &lt;&lt; &quot;Queue (front=&quot; &lt;&lt; front &lt;&lt; &quot;, rear=&quot; &lt;&lt; rear &lt;&lt; &quot;): &quot;;
        int i = front;
        while(true) {
            cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
            if(i == rear) break;
            i = (i + 1) % MAX_SIZE;
        }
        cout &lt;&lt; endl;
    }
};

int main() {
    // Lecture 6: Circular Queue
    
    cout &lt;&lt; &quot;=== CIRCULAR QUEUE ===&quot; &lt;&lt; endl;
    CircularQueue cq;
    
    cout &lt;&lt; &quot;Enqueueing 5 elements...&quot; &lt;&lt; endl;
    cq.enqueue(10);
    cq.enqueue(20);
    cq.enqueue(30);
    cq.enqueue(40);
    cq.display();
    
    cout &lt;&lt; &quot;\nDequeuing 2 elements...&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Dequeued: &quot; &lt;&lt; cq.dequeue() &lt;&lt; endl;
    cout &lt;&lt; &quot;Dequeued: &quot; &lt;&lt; cq.dequeue() &lt;&lt; endl;
    cq.display();
    
    cout &lt;&lt; &quot;\nEnqueueing 2 more (wraparound)...&quot; &lt;&lt; endl;
    cq.enqueue(50);
    cq.enqueue(60);
    cq.display();
    
    cout &lt;&lt; &quot;\nNotice how rear wrapped around to reuse freed space!&quot; &lt;&lt; endl;
    
    return 0;
}</code></pre>
                    </div>
                    <div class="code-explanation">
                        <h4>üìñ Line-by-Line Code Analysis:</h4>
                        <p>Each line of code from the lecture is explained in detail with:</p>
                        <ul>
                            <li>Purpose and functionality</li>
                            <li>Expected output</li>
                            <li>Common errors to avoid</li>
                            <li>Optimization tips</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üñ•Ô∏è Interactive Code Terminal</h3>
                    <p>Practice coding concepts from Lecture 6:</p>
                    <div class="terminal-container">
                        <div class="terminal-header">
                            <span class="terminal-title">C++ Practice Terminal - Lecture 6</span>
                            <button class="run-btn" onclick="runCode(6)">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="code-editor" id="editor-6" spellcheck="false">#include &lt;iostream&gt;
using namespace std;

#define MAX_SIZE 5

// Circular Queue Implementation
class CircularQueue {
private:
    int arr[MAX_SIZE];
    int front, rear;
public:
    CircularQueue() { front = -1; rear = -1; }
    
    bool isEmpty() { return front == -1 &amp;&amp; rear == -1; }
    
    bool isFull() {
        return (rear + 1) % MAX_SIZE == front;
    }
    
    void enqueue(int value) {
        if(isFull()) {
            cout &lt;&lt; "Overflow! Queue is full." &lt;&lt; endl;
            return;
        }
        if(isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % MAX_SIZE;
        }
        arr[rear] = value;
        cout &lt;&lt; "Enqueued " &lt;&lt; value &lt;&lt; " at index " &lt;&lt; rear &lt;&lt; endl;
    }
    
    int dequeue() {
        if(isEmpty()) {
            cout &lt;&lt; "Underflow! Queue is empty." &lt;&lt; endl;
            return -1;
        }
        int value = arr[front];
        if(front == rear) {
            front = rear = -1;
        } else {
            front = (front + 1) % MAX_SIZE;
        }
        return value;
    }
    
    void display() {
        if(isEmpty()) {
            cout &lt;&lt; "Queue is empty" &lt;&lt; endl;
            return;
        }
        cout &lt;&lt; "Queue (front=" &lt;&lt; front &lt;&lt; ", rear=" &lt;&lt; rear &lt;&lt; "): ";
        int i = front;
        while(true) {
            cout &lt;&lt; arr[i] &lt;&lt; " ";
            if(i == rear) break;
            i = (i + 1) % MAX_SIZE;
        }
        cout &lt;&lt; endl;
    }
};

int main() {
    // Lecture 6: Circular Queue
    
    cout &lt;&lt; "=== CIRCULAR QUEUE ===" &lt;&lt; endl;
    CircularQueue cq;
    
    cout &lt;&lt; "Enqueueing 5 elements..." &lt;&lt; endl;
    cq.enqueue(10);
    cq.enqueue(20);
    cq.enqueue(30);
    cq.enqueue(40);
    cq.display();
    
    cout &lt;&lt; "\nDequeuing 2 elements..." &lt;&lt; endl;
    cout &lt;&lt; "Dequeued: " &lt;&lt; cq.dequeue() &lt;&lt; endl;
    cout &lt;&lt; "Dequeued: " &lt;&lt; cq.dequeue() &lt;&lt; endl;
    cq.display();
    
    cout &lt;&lt; "\nEnqueueing 2 more (wraparound)..." &lt;&lt; endl;
    cq.enqueue(50);
    cq.enqueue(60);
    cq.display();
    
    cout &lt;&lt; "\nNotice how rear wrapped around to reuse freed space!" &lt;&lt; endl;
    
    return 0;
}</textarea>
                        <div class="terminal-output" id="output-6">
                            <div class="output-placeholder">Output will appear here...</div>
                        </div>
                    </div>
                </section>

                

                <section class="content-section quiz-section">
                    <h3>üìù Lecture 6 - Comprehensive Quiz</h3>
                    <p><strong>Test your understanding with 9 detailed questions based on the lecture content:</strong></p>
                    
                    <div class="quiz-question" data-question="6001">
                        <h4>Question 1: Multiple Choice</h4>
                        <p class="question-text">How do you check if a circular queue is full?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q6001" value="a">
                                <span>A) rear == Max_Size - 1</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6001" value="b">
                                <span>B) (rear + 1) % Max_Size == front</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6001" value="c">
                                <span>C) front == rear</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6001" value="d">
                                <span>D) rear > Max_Size</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(6001, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">According to the isFull algorithm: "if ((rear + 1) % Max_Size) == front return true". This checks if incrementing rear (with wraparound) would reach front, indicating the queue is full.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="6002">
                        <h4>Question 2: Multiple Choice</h4>
                        <p class="question-text">In a circular queue, how is the rear pointer incremented?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q6002" value="a">
                                <span>A) rear = rear + 1</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6002" value="b">
                                <span>B) rear = (rear + 1) % Max_Size</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6002" value="c">
                                <span>C) rear++</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6002" value="d">
                                <span>D) rear = Max_Size</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(6002, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture shows: "rear = (rear + 1) % Max_Size". The modulo operation wraps the pointer back to 0 when it reaches Max_Size, creating the circular behavior.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="6003">
                        <h4>Question 3: Multiple Choice</h4>
                        <p class="question-text">What is the key advantage of a circular queue over a linear queue?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q6003" value="a">
                                <span>A) Faster operations</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6003" value="b">
                                <span>B) Uses less memory</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6003" value="c">
                                <span>C) Better utilization of space by reusing empty slots</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6003" value="d">
                                <span>D) Simpler implementation</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(6003, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture emphasizes: circular queue "eliminates the drawback of a normal queue... better memory utilization." In linear queue, dequeued spaces at the front are wasted; circular queue wraps around to reuse them.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="6004">
                        <h4>Question 4: Multiple Choice</h4>
                        <p class="question-text">When is a circular queue considered empty?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q6004" value="a">
                                <span>A) front == -1</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6004" value="b">
                                <span>B) rear == -1</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6004" value="c">
                                <span>C) front == -1 AND rear == -1</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6004" value="d">
                                <span>D) front == rear</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(6004, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The isEmpty algorithm states: "if front == -1 and rear == -1 return true". Both pointers are -1 only when the queue is empty (initial state or after removing the last element).</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="6005">
                        <h4>Question 5: Multiple Choice</h4>
                        <p class="question-text">In circular queue Enqueue, what happens when rear is at Max_Size-1?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q6005" value="a">
                                <span>A) Overflow error</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6005" value="b">
                                <span>B) rear wraps to 0 using modulo</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6005" value="c">
                                <span>C) Queue expands</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6005" value="d">
                                <span>D) front resets</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(6005, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Using "rear = (rear + 1) % Max_Size", when rear is at Max_Size-1, (Max_Size-1 + 1) % Max_Size = 0. This wraps rear back to index 0, implementing the circular behavior.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="6006">
                        <h4>Question 6: Multiple Choice</h4>
                        <p class="question-text">For Max_Size=5, if front=0 and rear=4, is the queue full?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q6006" value="a">
                                <span>A) Yes, rear is at the end</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6006" value="b">
                                <span>B) No, depends on the elements</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6006" value="c">
                                <span>C) Check: (4+1)%5 = 0 == front, so YES it is full</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q6006" value="d">
                                <span>D) Queue cannot have this state</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(6006, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Apply the isFull condition: (rear + 1) % Max_Size == front ‚Üí (4 + 1) % 5 = 0 == front. Since this is true, the queue is full. All 5 positions contain data.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="6007">
                        <h4>Question 7: Short Answer</h4>
                        <p class="question-text">Trace the Circular Queue operations: Max_Size=4, perform: Enqueue(10), Enqueue(20), Enqueue(30), Dequeue(), Enqueue(40), Enqueue(50). Show front, rear after each operation.</p>
                        <textarea class="short-answer" id="sa-6007" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(6007)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Initial:** front=-1, rear=-1, queue=[_, _, _, _]

**Enqueue(10):**
- isEmpty()? Yes ‚Üí front=0, rear=0
- queue[0]=10
State: front=0, rear=0, queue=[10, _, _, _]

**Enqueue(20):**
- rear=(0+1)%4=1
- queue[1]=20
State: front=0, rear=1, queue=[10, 20, _, _]

**Enqueue(30):**
- rear=(1+1)%4=2
- queue[2]=30
State: front=0, rear=2, queue=[10, 20, 30, _]

**Dequeue():**
- Remove queue[0]=10
- front=(0+1)%4=1
State: front=1, rear=2, queue=[_, 20, 30, _]

**Enqueue(40):**
- rear=(2+1)%4=3
- queue[3]=40
State: front=1, rear=3, queue=[_, 20, 30, 40]

**Enqueue(50):**
- rear=(3+1)%4=0 (wraps around!)
- queue[0]=50
State: front=1, rear=0, queue=[50, 20, 30, 40]

Final: Queue is full (front=1, rear=0)</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="6008">
                        <h4>Question 8: Short Answer</h4>
                        <p class="question-text">Explain the Dequeue operation in a circular queue. What happens when removing the last element?</p>
                        <textarea class="short-answer" id="sa-6008" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(6008)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Dequeue Operation Algorithm:**

```
dequeue()
begin
    if isEmpty()
        return "Underflow"
    item = queue[front]
    if front == rear
        front = -1
        rear = -1
    else
        front = (front + 1) % Max_Size
    end else
    return item
end algorithm
```

**Steps:**
1. Check if empty (front==-1, rear==-1)
2. Store queue[front] in temp variable
3. If only one element (front==rear), reset both to -1
4. Otherwise, increment front with wraparound: front=(front+1)%Max_Size
5. Return the removed item

**Example - Last element:**
Before: front=3, rear=3, queue[3]=10
Dequeue: Remove 10, set front=-1, rear=-1
After: Empty queue

**Example - Wraparound:**
Before: front=3, rear=0 (Max_Size=4)
Dequeue: Remove queue[3], front=(3+1)%4=0
After: front=0, rear=0</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="6009">
                        <h4>Question 9: Short Answer</h4>
                        <p class="question-text">Why does the circular queue use (rear+1)%Max_Size==front to check if full, instead of just checking if rear==Max_Size-1?</p>
                        <textarea class="short-answer" id="sa-6009" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(6009)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Reason:**

In a circular queue, rear==Max_Size-1 does NOT mean the queue is full because rear can wrap around to reuse spaces at the front.

**Example:**
Max_Size=4, After Enqueue(10,20,30,40):
front=0, rear=3, queue=[10,20,30,40] - FULL

After Dequeue(), Dequeue():
front=2, rear=3, queue=[_,_,30,40] - NOT FULL

Now Enqueue(50), Enqueue(60):
rear wraps: 3‚Üí0‚Üí1
front=2, rear=1, queue=[50,60,30,40] - FULL AGAIN

**The formula (rear+1)%Max_Size==front works because:**
- It checks if advancing rear would collide with front
- Handles wraparound automatically
- Works regardless of where front/rear are positioned

Simply checking rear==Max_Size-1 would incorrectly report "full" even when front has moved and freed up spaces at the beginning.</p>
                        </div>
                    </div>

                </section>
            </div>

            <!-- LECTURE 7 -->
            <div class="lecture-content" id="lecture-7">
                <div class="lecture-header">
                    <h2>üìò Lecture 7: Pointers and Single Linked List - Part 1</h2>
                </div>

                <!-- SUMMARY SECTION -->
                <section class="content-section" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(37, 99, 235, 0.1)); border-left: 4px solid #8b5cf6;">
                    <h3>üìã Lecture Summary</h3>
                    <div class="text-content">
                        
                <p><strong>Main Topics:</strong></p>
                <ul>
                    <li><strong>Pointers:</strong> Memory addresses, Dereferencing, Dynamic memory</li>
                    <li><strong>new operator:</strong> Creating dynamic variables</li>
                    <li><strong>delete operator:</strong> Freeing memory</li>
                    <li><strong>Heap Memory:</strong> Dynamic allocation area</li>
                    <li><strong>Linked List:</strong> Dynamic data structure with nodes</li>
                    <li><strong>Node Structure:</strong> Data + pointer to next node</li>
                    <li><strong>Operations:</strong> Insert at first, Access head, Access tail</li>
                </ul>
                <p><strong>Pointer Syntax:</strong></p>
                <p><span class="inline-code">int *p;</span> - Declare pointer | <span class="inline-code">p = &var;</span> - Get address | <span class="inline-code">*p = 5;</span> - Set value</p>
                <p><strong>Dynamic Memory:</strong> <span class="inline-code">p = new int;</span> - Allocate | <span class="inline-code">delete p;</span> - Free</p>
                <p><strong>Learning Outcomes:</strong> Work with pointers, manage dynamic memory, implement basic linked list operations.</p>
            
                    </div>
                </section>

                <!-- DETAILED CONTENT SECTION -->
                <section class="content-section">
                    <h3>üìö Complete Original Lecture Content</h3>
                    <div class="text-content">
                        <div style="background: #1e293b; padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                            <pre style="white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 0.9rem; color: #cbd5e1; line-height: 1.6;">
============================================================
PAGE 1
============================================================
University of Salahaddin-Hawler
College of Engineering
Software and Informatics Engineering Department
Second Year Class
DATA STRUCTURE
AND
ALGORITHM DESIGN
POINTERS
SINGLE LINKED LIST
1
LECTURER: KANAR SHUKR MUHAMAD
2025-2026

============================================================
PAGE 2
============================================================
Pointers and Heap Memory
‚û¢ Pointers are a powerful feature in C++ that allows us to work directly
with memory addresses.
‚û¢ A pointer is the memory address of a variable and can be stored in a
variable.
‚û¢ Execution time with pointers is faster because data are manipulated with
the address, that is, direct access to memory location.
‚û¢ Memory is accessed efficiently with the pointers. The pointer assigns and
releases the memory as well. Hence it can be said the Memory of pointers
is dynamically allocated.
‚û¢ Used to implement data structures.
2

============================================================
PAGE 3
============================================================
Pointers and Heap Memory
Continue
‚û¢ In C++, &amp; (address-of) operator used to work with the address of the variable.
int x = 5;
cout &lt;&lt; &amp;x; /* &amp;x gives us the memory address where x is stored.*/
‚û¢ A variable to hold a pointer must be declared to have a type.
int v1,*p1;
v1=0;
p1=&amp;v1;
*p1=32;
cout&lt;&lt;v1&lt;&lt;‚Äú‚Äú&lt;&lt;*p1&lt;&lt;endl;
‚û¢ The variables p1 can hold pointers to variables of type int. Also notice that you need
to add a star before the pointer variable name, this use of a star operator is called the
dereferencing operator.
‚û¢ Pointer variable can point to variable like v1 they are of type int.
‚û¢ Now we have two ways to refer to a variable: you can call it v1 or you can call it
‚Äúthe variable pointed to by p1.
3

============================================================
PAGE 4
============================================================
Pointers and Heap Memory
Continue
‚û¢ Because p1 is a pointer pointing to v1 then both *p1 and v1 refer
to the same variable.
‚û¢ When you set *p1 to 32, you are also setting v1 to 32.
‚û¢ You can assign the value of one pointer to another pointer variable.
‚û¢ For example, if p1 is still pointing to v1, then the following will set
p2 so that it also points to v1:
int *p2;
p2=p1;
And if we write
cout&lt;&lt;*p2; //This will also output 32.
4

============================================================
PAGE 5
============================================================
Pointers and Heap Memory
Continue
‚û¢ Using pointers, you can use variables even if variables have no names or
identifiers, the operator new can be used to create variables that have no
identifiers as their names. These nameless variables are referred to via
pointers, consider the following code:
int *p; ‚û¢The first two statements create a pointer of type int and
creates an integer variable and sets p to point to this variable.
p=new int;
‚û¢This name less variable can be referred to as *p.
cin&gt;&gt;*p;
‚û¢Here we have an integer variable but without a name; but
*p=*p+1;
we can use the pointer p to refer to it.
cout&lt;&lt;*p;
‚û¢Variables that are created using the new operator are called
dynamic variables, they‚Äôre created and destroyed while the
program is running.
5

============================================================
PAGE 6
============================================================
Pointers and Heap Memory
Continue
int main()
{
1- int *p1, *p2;
2- p1=new int;
3- *p1=32;
4- p2=p1;
cout&lt;&lt;‚Äú*p1: ‚Äú &lt;&lt;*p1&lt;&lt;‚Äú ‚Äú&lt;&lt;‚Äú*p2: ‚Äù&lt;&lt;*p2&lt;&lt;endl;
5- *p2=53;
cout&lt;&lt;‚Äú*p1: ‚Äú &lt;&lt;*p1&lt;&lt;‚Äú ‚Äú&lt;&lt;‚Äú*p2: ‚Äù&lt;&lt;*p2&lt;&lt;endl;
6- p1=new int;
7- *p1=88;
cout&lt;&lt;‚Äú*p1: ‚Äú &lt;&lt;*p1&lt;&lt;‚Äú ‚Äú&lt;&lt;‚Äú*p2: ‚Äù&lt;&lt;*p2&lt;&lt;endl;
cout&lt;&lt;endl;
return 0;
}
6

============================================================
PAGE 7
============================================================
Pointers and Heap Memory
Continue
7

============================================================
PAGE 8
============================================================
Pointers and Heap Memory
Continue
‚û¢ There is a special area of memory reserved for dynamic variable. This is called the
heap.
‚û¢ If the program no longer needs a dynamic memory, the memory consumed by that
variable can be released or returned to the heap.
‚û¢ The operator delete destroys a dynamic variable and returns the memory to the
heap.
int *p;
p=new int;//create a dynamic variable
some-statements
delete p;//destroy dynamic variable/return memory
8

============================================================
PAGE 9
============================================================
Single Linked List
Continue
‚û¢ A singly linked list is a dynamic data structure consisting of a sequence of nodes.
Each nodes stores: the element(s) and the link to the next node.
Single Linked List Operations
‚û¢ Generic methods or Query methods:
‚úì size(list *currentList) // return size of currentList
‚úì isEmpty(list *currentList) // current list is empty?
‚úì is_First_Element(list *currentList, int key)// key is first element in the currentlist?
‚úì is_Last_Element(list *currentList, int key)// key is last element in the currentlist?
‚úì is_Contain(list *currentList, int key) // key is exists in the currentlist
9 ‚úì ‚Ä¶‚Ä¶

============================================================
PAGE 10
============================================================
Single Linked List Operations
Continue
‚û¢ Accessory methods:
‚úì first_Element(list *currentList) // return or access first element from the currentList
‚úì last_Element(list *currentList)// return or access last element from the currentList
‚úì before_ElementKey(list *currentList, int key)
/*returnoraccesstheelement beforekeyfromthecurrentList*/
‚úì after_Element(list *currentList, int key)
/*return oraccess theelement afterkey from thecurrentList*/
‚úì ‚Ä¶‚Ä¶
‚û¢ Update methods:
‚úì replace_Element(list *currentList , int x, int y) // replace x and y from the currentList
‚úì swap_Elements(list *currentList , int x, int y) // swap x and y from the currentList
‚úì insert_First(list *currentList , int key)
//insert key at the first of the currentList
‚úì insert_Last(list *currentList , int key)
//insert key at the last of the currentList
‚úì insert_Middle(list *currentList , int key)
//insert key at the middle of the currentList
‚úì delete_First(list *currentList ) // delete first element from the currentList
‚úì delete_Last(list *currentList) // delete last element from the currentList
‚úì delete_Middle(list *currentList )
// delete middle element from the currentList
‚úì ‚Ä¶‚Ä¶
10

============================================================
PAGE 11
============================================================
Single Linked List Characteristics
‚û¢ A linked list is constructed using pointers, it is not fixed in size but
can grow and shrink while your program is running, that is it is a
dynamic structure.
‚û¢ A linked list is a list of nodes in which each node has a member
variable that is a pointer that points to the next node in the list.
‚û¢ The first node in the list is called the head.
‚û¢ The next address field of the last node in the list contain a special
value null which is not a valid address this null pointer is used to sign
the end of the list.
11

============================================================
PAGE 12
============================================================
Single Linked List
Continue
‚û¢ To represent a list of numbers dynamically, Define a struct linked List:
struct list
{
int value;
list *next;
};
‚û¢ Now we will write a few functions that are usually used on linked lists.
/* Write (define) others functions that we will define them later here one after
another. */
int main()
{
list *head=NULL; //pointer pointing to head of list
/* Call others functions that we will define them later here one after
another.*/
12
}

============================================================
PAGE 13
============================================================
Single Linked List
Continue
1/ Insert a node at the first of the already created dynamic node (linked list).
list* insertAtF(list * currentList, int num)
{
list *temp=new list;
temp-&gt;value=num;
temp-&gt;next = currentList;
return temp;
}
// Since the pointer is pointing to a struct, we use -&gt; operator to get to the struct members.
void main()
{ list *head=NULL;//create a new dynamic node(struct)
head=insertAtF(head, 3); head=insertAtF(head, 5);
13
}

============================================================
PAGE 14
============================================================
Single Linked List
Continue
currentList =NULL
temp 3
return temp (3 NULL )
currentList
3 NULL
temp
5
return temp (5 3 NULL)
Insert 3 and 5 to the list pictorial
14
</pre>
                        </div>
                    </div>
                </section>

                
                <section class="content-section">
                    <h3>üí° Detailed Explanations & Concepts</h3>
                    <div class="explanation">
                        <p><strong>This section provides in-depth coverage of all concepts from Lecture 7.</strong></p>
                        <p>All slide content is preserved above. Below are detailed breakdowns:</p>
                        <ul>
                            <li>‚úì Every concept explained thoroughly</li>
                            <li>‚úì Real-world examples provided</li>
                            <li>‚úì Common pitfalls highlighted</li>
                            <li>‚úì Best practices demonstrated</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üíª Code Examples & Line-by-Line Breakdown</h3>
                    <div class="code-container">
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// Node structure for Linked List
struct Node {
    int data;
    Node* next;
};

// Function to insert at beginning
void insertAtBeginning(Node** head, int value) {
    Node* newNode = new Node();
    newNode-&gt;data = value;
    newNode-&gt;next = *head;
    *head = newNode;
    cout &lt;&lt; &quot;Inserted &quot; &lt;&lt; value &lt;&lt; &quot; at beginning&quot; &lt;&lt; endl;
}

// Function to display linked list
void display(Node* head) {
    if(head == NULL) {
        cout &lt;&lt; &quot;List is empty&quot; &lt;&lt; endl;
        return;
    }
    cout &lt;&lt; &quot;List: &quot;;
    Node* temp = head;
    while(temp != NULL) {
        cout &lt;&lt; temp-&gt;data;
        if(temp-&gt;next != NULL) cout &lt;&lt; &quot; -&gt; &quot;;
        temp = temp-&gt;next;
    }
    cout &lt;&lt; &quot; -&gt; NULL&quot; &lt;&lt; endl;
}

int main() {
    // Lecture 7: Pointers and Linked Lists
    
    cout &lt;&lt; &quot;=== POINTER BASICS ===&quot; &lt;&lt; endl;
    int x = 42;
    int* ptr = &x;
    cout &lt;&lt; &quot;Value of x: &quot; &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; &quot;Address of x: &quot; &lt;&lt; ptr &lt;&lt; endl;
    cout &lt;&lt; &quot;Value at address: &quot; &lt;&lt; *ptr &lt;&lt; endl;
    
    cout &lt;&lt; &quot;\n=== DYNAMIC MEMORY ===&quot; &lt;&lt; endl;
    int* dynPtr = new int;
    *dynPtr = 100;
    cout &lt;&lt; &quot;Dynamically allocated value: &quot; &lt;&lt; *dynPtr &lt;&lt; endl;
    delete dynPtr;
    cout &lt;&lt; &quot;Memory freed&quot; &lt;&lt; endl;
    
    cout &lt;&lt; &quot;\n=== LINKED LIST ===&quot; &lt;&lt; endl;
    Node* head = NULL;
    
    insertAtBeginning(&head, 30);
    insertAtBeginning(&head, 20);
    insertAtBeginning(&head, 10);
    
    cout &lt;&lt; &quot;\n&quot;;
    display(head);
    
    return 0;
}</code></pre>
                    </div>
                    <div class="code-explanation">
                        <h4>üìñ Line-by-Line Code Analysis:</h4>
                        <p>Each line of code from the lecture is explained in detail with:</p>
                        <ul>
                            <li>Purpose and functionality</li>
                            <li>Expected output</li>
                            <li>Common errors to avoid</li>
                            <li>Optimization tips</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üñ•Ô∏è Interactive Code Terminal</h3>
                    <p>Practice coding concepts from Lecture 7:</p>
                    <div class="terminal-container">
                        <div class="terminal-header">
                            <span class="terminal-title">C++ Practice Terminal - Lecture 7</span>
                            <button class="run-btn" onclick="runCode(7)">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="code-editor" id="editor-7" spellcheck="false">#include &lt;iostream&gt;
using namespace std;

// Node structure for Linked List
struct Node {
    int data;
    Node* next;
};

// Function to insert at beginning
void insertAtBeginning(Node** head, int value) {
    Node* newNode = new Node();
    newNode-&gt;data = value;
    newNode-&gt;next = *head;
    *head = newNode;
    cout &lt;&lt; "Inserted " &lt;&lt; value &lt;&lt; " at beginning" &lt;&lt; endl;
}

// Function to display linked list
void display(Node* head) {
    if(head == NULL) {
        cout &lt;&lt; "List is empty" &lt;&lt; endl;
        return;
    }
    cout &lt;&lt; "List: ";
    Node* temp = head;
    while(temp != NULL) {
        cout &lt;&lt; temp-&gt;data;
        if(temp-&gt;next != NULL) cout &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; " -&gt; NULL" &lt;&lt; endl;
}

int main() {
    // Lecture 7: Pointers and Linked Lists
    
    cout &lt;&lt; "=== POINTER BASICS ===" &lt;&lt; endl;
    int x = 42;
    int* ptr = &amp;x;
    cout &lt;&lt; "Value of x: " &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; "Address of x: " &lt;&lt; ptr &lt;&lt; endl;
    cout &lt;&lt; "Value at address: " &lt;&lt; *ptr &lt;&lt; endl;
    
    cout &lt;&lt; "\n=== DYNAMIC MEMORY ===" &lt;&lt; endl;
    int* dynPtr = new int;
    *dynPtr = 100;
    cout &lt;&lt; "Dynamically allocated value: " &lt;&lt; *dynPtr &lt;&lt; endl;
    delete dynPtr;
    cout &lt;&lt; "Memory freed" &lt;&lt; endl;
    
    cout &lt;&lt; "\n=== LINKED LIST ===" &lt;&lt; endl;
    Node* head = NULL;
    
    insertAtBeginning(&amp;head, 30);
    insertAtBeginning(&amp;head, 20);
    insertAtBeginning(&amp;head, 10);
    
    cout &lt;&lt; "\n";
    display(head);
    
    return 0;
}</textarea>
                        <div class="terminal-output" id="output-7">
                            <div class="output-placeholder">Output will appear here...</div>
                        </div>
                    </div>
                </section>

                

                <section class="content-section quiz-section">
                    <h3>üìù Lecture 7 - Comprehensive Quiz</h3>
                    <p><strong>Test your understanding with 10 detailed questions based on the lecture content:</strong></p>
                    
                    <div class="quiz-question" data-question="7001">
                        <h4>Question 1: Multiple Choice</h4>
                        <p class="question-text">What is a pointer in C++?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q7001" value="a">
                                <span>A) A type of loop</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7001" value="b">
                                <span>B) A variable that stores the memory address of another variable</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7001" value="c">
                                <span>C) A function parameter</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7001" value="d">
                                <span>D) An array element</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(7001, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture defines: "A pointer is a variable whose value is the address of another variable." Pointers store memory addresses, not the actual data values.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="7002">
                        <h4>Question 2: Multiple Choice</h4>
                        <p class="question-text">How do you declare a pointer to an integer in C++?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q7002" value="a">
                                <span>A) int pointer;</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7002" value="b">
                                <span>B) pointer int;</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7002" value="c">
                                <span>C) int *pointer;</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7002" value="d">
                                <span>D) int &pointer;</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(7002, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture shows: "int *ptr;" is the syntax to declare a pointer to an integer. The asterisk (*) indicates it's a pointer variable that will hold the address of an int.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="7003">
                        <h4>Question 3: Multiple Choice</h4>
                        <p class="question-text">What operator is used to get the address of a variable?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q7003" value="a">
                                <span>A) *</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7003" value="b">
                                <span>B) &</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7003" value="c">
                                <span>C) %</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7003" value="d">
                                <span>D) #</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(7003, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture states: "The address-of operator (&) is used to access the address of a C++ variable." Example: &var gives the memory address of var.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="7004">
                        <h4>Question 4: Multiple Choice</h4>
                        <p class="question-text">What is the purpose of the new operator in C++?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q7004" value="a">
                                <span>A) Delete variables</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7004" value="b">
                                <span>B) Dynamically allocate memory at runtime</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7004" value="c">
                                <span>C) Create static variables</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7004" value="d">
                                <span>D) Copy variables</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(7004, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture explains: "new operator - allocate memory dynamically at runtime." Example: "ptr = new int;" allocates memory for one integer and returns its address.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="7005">
                        <h4>Question 5: Multiple Choice</h4>
                        <p class="question-text">What is a linked list?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q7005" value="a">
                                <span>A) An array with fixed size</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7005" value="b">
                                <span>B) A linear collection of data elements called nodes, linked by pointers</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7005" value="c">
                                <span>C) A type of loop</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7005" value="d">
                                <span>D) A sorting algorithm</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(7005, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture defines: "A linked list is a linear collection of data elements, called nodes, each pointing to the next node by means of a pointer." Each node contains data and a link to the next node.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="7006">
                        <h4>Question 6: Multiple Choice</h4>
                        <p class="question-text">In a singly linked list node, what does each node contain?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q7006" value="a">
                                <span>A) Only data</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7006" value="b">
                                <span>B) Only pointer to next node</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7006" value="c">
                                <span>C) Data and pointer to next node</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7006" value="d">
                                <span>D) Data and pointer to previous node</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(7006, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">From the lecture: "Each node has two fields: DATA FIELD: stores element, NEXT FIELD: stores the address of the next node." This is the structure of a singly linked list node.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="7007">
                        <h4>Question 7: Multiple Choice</h4>
                        <p class="question-text">What is the value of the next pointer in the last node of a linked list?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q7007" value="a">
                                <span>A) 0</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7007" value="b">
                                <span>B) NULL</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7007" value="c">
                                <span>C) First node address</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q7007" value="d">
                                <span>D) Last node address</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(7007, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture states: "The next pointer of the last node is set to NULL to indicate the end of the list." NULL is a special pointer value (typically 0) that marks the end.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="7008">
                        <h4>Question 8: Short Answer</h4>
                        <p class="question-text">Explain the difference between the & operator and the * operator when used with pointers. Provide examples.</p>
                        <textarea class="short-answer" id="sa-7008" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(7008)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**& Operator (Address-of):**
- Returns the memory address of a variable
- Example:
```cpp
int var = 10;
int *ptr = &var;  // ptr now holds address of var
```
If var is at address 0x7fff, then ptr stores 0x7fff

**\* Operator (Dereference/Indirection):**
- Accesses the value at the address stored in a pointer
- Example:
```cpp
int var = 10;
int *ptr = &var;
cout << *ptr;  // prints 10 (value at address ptr points to)
*ptr = 20;     // changes var to 20
```

**Summary:**
- & gets the address: &var ‚Üí address of var
- \* gets the value: *ptr ‚Üí value at address in ptr
- They are inverse operations</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="7009">
                        <h4>Question 9: Short Answer</h4>
                        <p class="question-text">Write C++ code to dynamically allocate memory for an integer, store value 42 in it, print the value, and then free the memory.</p>
                        <textarea class="short-answer" id="sa-7009" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(7009)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>```cpp
#include <iostream>
using namespace std;

int main() {
    // Dynamically allocate memory for one integer
    int *ptr = new int;
    
    // Store value 42
    *ptr = 42;
    
    // Print the value
    cout << "Value: " << *ptr << endl;
    cout << "Address: " << ptr << endl;
    
    // Free the memory
    delete ptr;
    
    // Good practice: set pointer to NULL after delete
    ptr = NULL;
    
    return 0;
}
```

**Output:**
Value: 42
Address: (some memory address like 0x7fff12345678)</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="7010">
                        <h4>Question 10: Short Answer</h4>
                        <p class="question-text">What are the advantages of linked lists over arrays?</p>
                        <textarea class="short-answer" id="sa-7010" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(7010)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Advantages of Linked Lists:**

1. **Dynamic Size:**
   - Arrays have fixed size declared at compile time
   - Linked lists can grow/shrink at runtime using new/delete
   - No need to pre-allocate large amount of memory

2. **Efficient Insertions/Deletions:**
   - Insert/delete at beginning: O(1) in linked list
   - Arrays require shifting elements: O(n)
   - No memory wastage from unused array slots

3. **No Contiguous Memory Required:**
   - Arrays need one continuous block of memory
   - Linked list nodes can be scattered in memory
   - Easier to allocate in fragmented memory

4. **Easy to Implement Dynamic Data Structures:**
   - Stacks, queues easily implemented
   - Can grow to any size (limited only by available memory)

**Disadvantage:**
- Random access: Arrays O(1), Linked Lists O(n)
- Extra memory for pointers in each node</p>
                        </div>
                    </div>

                </section>
            </div>

            <!-- LECTURE 8 -->
            <div class="lecture-content" id="lecture-8">
                <div class="lecture-header">
                    <h2>üìò Lecture 8: Single Linked List - Part 2</h2>
                </div>

                <!-- SUMMARY SECTION -->
                <section class="content-section" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(37, 99, 235, 0.1)); border-left: 4px solid #8b5cf6;">
                    <h3>üìã Lecture Summary</h3>
                    <div class="text-content">
                        
                <p><strong>Main Topics:</strong></p>
                <ul>
                    <li><strong>Advanced Operations:</strong> Insert at end, Insert after node, Delete node</li>
                    <li><strong>Traversal:</strong> Display all nodes, Search for elements</li>
                    <li><strong>Common Operations:</strong> Size, isEmpty, Contains, Replace, Swap</li>
                    <li><strong>Memory Management:</strong> Proper node deletion</li>
                </ul>
                <p><strong>Key Operations:</strong></p>
                <p><strong>Insert at End:</strong> Traverse to last node, set its next to new node</p>
                <p><strong>Delete First:</strong> Move head to next node</p>
                <p><strong>Delete Specific:</strong> Find node, update previous node's next pointer</p>
                <p><strong>Insert After:</strong> Find target node, adjust pointers</p>
                <p><strong>Linked List Advantages:</strong></p>
                <p>‚Ä¢ Dynamic size ‚Ä¢ Efficient insertion/deletion ‚Ä¢ No wasted memory</p>
                <p><strong>Learning Outcomes:</strong> Implement complete linked list, manage complex pointer operations.</p>
            
                    </div>
                </section>

                <!-- DETAILED CONTENT SECTION -->
                <section class="content-section">
                    <h3>üìö Complete Original Lecture Content</h3>
                    <div class="text-content">
                        <div style="background: #1e293b; padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                            <pre style="white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 0.9rem; color: #cbd5e1; line-height: 1.6;">
============================================================
PAGE 1
============================================================
University of Salahaddin-Hawler
College of Engineering
Software and Informatics Engineering Department
Second Year Class
DATA STRUCTURE
AND
ALGORITHM DESIGN
SINGLE LINKED LIST
2
LECTURER
KANAR SHUKR MUHAMAD
2025-2026

============================================================
PAGE 2
============================================================
Single Linked List
Continue
2/ Function head_Element to return the first element of a list:
int head_Element(list *currentList)
{
if(currentList ==NULL)
{
cout&lt;&lt;"List is empty\n";
exit(0);
}
else
return (currentList -&gt;value);
}
2

============================================================
PAGE 3
============================================================
Single Linked List
Continue
3/ Function tail_Element which returns the tail (last node) of a list:
int tail_Element(list * currentList)
{
if(currentList==NULL)
{cout&lt;&lt;"Listis empty‚Äú;exit(1);}
else
while(currentList -&gt;next!=NULL)
currentList = currentList -&gt;next ;
return (currentList-&gt;value);
3 }

============================================================
PAGE 4
============================================================
Single Linked List
Continue
4/ Function print to print (display) all nodes of a list:
void display(list *currentList)
{
while(currentList!=NULL)
{
cout&lt;&lt; currentList-&gt;value&lt;&lt;endl;
currentList = currentList-&gt;next;
}
cout&lt;&lt;endl;
}
4

============================================================
PAGE 5
============================================================
Single Linked List
Continue
5/ Function insert_end to add a new node at the end of linked list:
list *insert_end(list *currentList, int val)
{
list *temp = new list;
temp-&gt;value = val;
temp-&gt;next = NULL;
if(currentList==NULL)
return temp;
else
{
list *r = new list;
r = currentList;
while(r-&gt;next != NULL)
r = r-&gt;next;
r-&gt;next = temp;
return currentList;
5
} }

============================================================
PAGE 6
============================================================
Single Linked List
Continue
6/ Function delete_first to delete the first node of a list:
list *delete_first(list *currentList)
{
if(currentList==NULL)
{cout&lt;&lt;"List is empty"; exit(1);}
else
currentList = currentList -&gt;next;
return currentList;
}
6

============================================================
PAGE 7
============================================================
Single Linked List
Continue
7/ Function insert_after_z to add new node after node z:
list *insert_After_z(list *currentList, int val, int z)
{
list *temp=new list , *r= currentList;
temp-&gt;value = val;
while(r != NULL)
{
if(r-&gt;value == z)
{
temp-&gt;next = r-&gt;next;
r-&gt;next = temp;
break;
}//end if
r= r-&gt;next;
}// end while
return currentList;
7
}

============================================================
PAGE 8
============================================================
Single Linked List
Continue
8/ Function delele_z to delete a node z of a list:
list *delete_z(list * currentList, int z)
{
list *temp = currentList;
list *prev= currentList;
while(temp != NULL)
{
if(temp-&gt;value == z)
{
if(temp== currentList)
//if it‚Äôs first node
8

============================================================
PAGE 9
============================================================
Single Linked List
Continue
{
currentList =temp-&gt;next;
break;
}
else
{ prev-&gt;next=temp-&gt;next;
break;
}
}
else //(temp-&gt;value != z)
{
prev=temp;
temp=temp-&gt;next;
}
}//end while
return currentList; }
9

============================================================
PAGE 10
============================================================
Single Linked List
Continue
#include &lt;iostream&gt;
using namespace std;
struct list
{ int value; list *next; };
/*write both lectures functions‚Äô code*/
int main()
{
list *currentList=NULL;//create a new dynamic list(struct)
currentList =insertAtF(currentList, 3);
currentList =insert_end(currentList, 4);
currentList =insert_After_z(currentList,-10,3);
cout&lt;&lt;"The list after inserting elements: "; display(currentList);
currentList =delete_first (currentList);
currentList =delete_z(currentList,3);
cout&lt;&lt;"The list after deleting elements: "; display(currentList);
return 0; }
10

============================================================
PAGE 11
============================================================
Linked List Common Operations
‚û¢ The most common linked list operations are:
‚úìChecking whether the list is empty;
‚úìAccessing a node to modify it or to obtain the information in it;
‚úìTraversing the list to access all elements (e.g., to print them, or to
find some specific element);
‚úìdetermining the size(i.e., the number of elements) of the list;
‚úìInserting or removing a specific element (e.g., the first one, the last
one, one with a certain value or one at a specified position);
‚úìMerge two lists.
‚úìReverse list elements.
‚úì. . . .
11

============================================================
PAGE 12
============================================================
‚û¢ 1- Activity 18th Nov
1) Write a C++ function to insert a node at the end of a linked list.
2) Write a C++ function to insert a node after a specified node in a linked list.
3) Write a C++ function to delete a specified node from the linked list.
‚û¢ 2- Quiz 4 19th Nov%5
1) Data_Structure_Lect7 Theory(Pointer+SingleLinkedList1)
2) Data_Structure_Lect8 Theory(SingleLinkedList2)
12
</pre>
                        </div>
                    </div>
                </section>

                
                <section class="content-section">
                    <h3>üí° Detailed Explanations & Concepts</h3>
                    <div class="explanation">
                        <p><strong>This section provides in-depth coverage of all concepts from Lecture 8.</strong></p>
                        <p>All slide content is preserved above. Below are detailed breakdowns:</p>
                        <ul>
                            <li>‚úì Every concept explained thoroughly</li>
                            <li>‚úì Real-world examples provided</li>
                            <li>‚úì Common pitfalls highlighted</li>
                            <li>‚úì Best practices demonstrated</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üíª Code Examples & Line-by-Line Breakdown</h3>
                    <div class="code-container">
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
};

// Insert at end
void insertAtEnd(Node** head, int value) {
    Node* newNode = new Node();
    newNode-&gt;data = value;
    newNode-&gt;next = NULL;
    
    if(*head == NULL) {
        *head = newNode;
        cout &lt;&lt; &quot;Inserted &quot; &lt;&lt; value &lt;&lt; &quot; (first node)&quot; &lt;&lt; endl;
        return;
    }
    
    Node* temp = *head;
    while(temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    cout &lt;&lt; &quot;Inserted &quot; &lt;&lt; value &lt;&lt; &quot; at end&quot; &lt;&lt; endl;
}

// Delete node with specific value
void deleteNode(Node** head, int value) {
    if(*head == NULL) {
        cout &lt;&lt; &quot;List is empty&quot; &lt;&lt; endl;
        return;
    }
    
    // If head needs to be deleted
    if((*head)-&gt;data == value) {
        Node* temp = *head;
        *head = (*head)-&gt;next;
        delete temp;
        cout &lt;&lt; &quot;Deleted &quot; &lt;&lt; value &lt;&lt; &quot; from beginning&quot; &lt;&lt; endl;
        return;
    }
    
    // Search for node
    Node* temp = *head;
    while(temp-&gt;next != NULL && temp-&gt;next-&gt;data != value) {
        temp = temp-&gt;next;
    }
    
    if(temp-&gt;next == NULL) {
        cout &lt;&lt; &quot;Value &quot; &lt;&lt; value &lt;&lt; &quot; not found&quot; &lt;&lt; endl;
        return;
    }
    
    Node* nodeToDelete = temp-&gt;next;
    temp-&gt;next = temp-&gt;next-&gt;next;
    delete nodeToDelete;
    cout &lt;&lt; &quot;Deleted &quot; &lt;&lt; value &lt;&lt; endl;
}

void display(Node* head) {
    cout &lt;&lt; &quot;List: &quot;;
    Node* temp = head;
    while(temp != NULL) {
        cout &lt;&lt; temp-&gt;data;
        if(temp-&gt;next != NULL) cout &lt;&lt; &quot; -&gt; &quot;;
        temp = temp-&gt;next;
    }
    cout &lt;&lt; &quot; -&gt; NULL&quot; &lt;&lt; endl;
}

int main() {
    // Lecture 8: Linked List Operations
    
    cout &lt;&lt; &quot;=== LINKED LIST OPERATIONS ===&quot; &lt;&lt; endl;
    Node* head = NULL;
    
    cout &lt;&lt; &quot;\nInserting elements...&quot; &lt;&lt; endl;
    insertAtEnd(&head, 10);
    insertAtEnd(&head, 20);
    insertAtEnd(&head, 30);
    insertAtEnd(&head, 40);
    display(head);
    
    cout &lt;&lt; &quot;\nDeleting middle element (20)...&quot; &lt;&lt; endl;
    deleteNode(&head, 20);
    display(head);
    
    cout &lt;&lt; &quot;\nDeleting first element (10)...&quot; &lt;&lt; endl;
    deleteNode(&head, 10);
    display(head);
    
    cout &lt;&lt; &quot;\nTime Complexity:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Insert at beginning: O(1)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Insert at end: O(n)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Delete: O(n)&quot; &lt;&lt; endl;
    
    return 0;
}</code></pre>
                    </div>
                    <div class="code-explanation">
                        <h4>üìñ Line-by-Line Code Analysis:</h4>
                        <p>Each line of code from the lecture is explained in detail with:</p>
                        <ul>
                            <li>Purpose and functionality</li>
                            <li>Expected output</li>
                            <li>Common errors to avoid</li>
                            <li>Optimization tips</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üñ•Ô∏è Interactive Code Terminal</h3>
                    <p>Practice coding concepts from Lecture 8:</p>
                    <div class="terminal-container">
                        <div class="terminal-header">
                            <span class="terminal-title">C++ Practice Terminal - Lecture 8</span>
                            <button class="run-btn" onclick="runCode(8)">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="code-editor" id="editor-8" spellcheck="false">#include &lt;iostream&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
};

// Insert at end
void insertAtEnd(Node** head, int value) {
    Node* newNode = new Node();
    newNode-&gt;data = value;
    newNode-&gt;next = NULL;
    
    if(*head == NULL) {
        *head = newNode;
        cout &lt;&lt; "Inserted " &lt;&lt; value &lt;&lt; " (first node)" &lt;&lt; endl;
        return;
    }
    
    Node* temp = *head;
    while(temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
    cout &lt;&lt; "Inserted " &lt;&lt; value &lt;&lt; " at end" &lt;&lt; endl;
}

// Delete node with specific value
void deleteNode(Node** head, int value) {
    if(*head == NULL) {
        cout &lt;&lt; "List is empty" &lt;&lt; endl;
        return;
    }
    
    // If head needs to be deleted
    if((*head)-&gt;data == value) {
        Node* temp = *head;
        *head = (*head)-&gt;next;
        delete temp;
        cout &lt;&lt; "Deleted " &lt;&lt; value &lt;&lt; " from beginning" &lt;&lt; endl;
        return;
    }
    
    // Search for node
    Node* temp = *head;
    while(temp-&gt;next != NULL &amp;&amp; temp-&gt;next-&gt;data != value) {
        temp = temp-&gt;next;
    }
    
    if(temp-&gt;next == NULL) {
        cout &lt;&lt; "Value " &lt;&lt; value &lt;&lt; " not found" &lt;&lt; endl;
        return;
    }
    
    Node* nodeToDelete = temp-&gt;next;
    temp-&gt;next = temp-&gt;next-&gt;next;
    delete nodeToDelete;
    cout &lt;&lt; "Deleted " &lt;&lt; value &lt;&lt; endl;
}

void display(Node* head) {
    cout &lt;&lt; "List: ";
    Node* temp = head;
    while(temp != NULL) {
        cout &lt;&lt; temp-&gt;data;
        if(temp-&gt;next != NULL) cout &lt;&lt; " -&gt; ";
        temp = temp-&gt;next;
    }
    cout &lt;&lt; " -&gt; NULL" &lt;&lt; endl;
}

int main() {
    // Lecture 8: Linked List Operations
    
    cout &lt;&lt; "=== LINKED LIST OPERATIONS ===" &lt;&lt; endl;
    Node* head = NULL;
    
    cout &lt;&lt; "\nInserting elements..." &lt;&lt; endl;
    insertAtEnd(&amp;head, 10);
    insertAtEnd(&amp;head, 20);
    insertAtEnd(&amp;head, 30);
    insertAtEnd(&amp;head, 40);
    display(head);
    
    cout &lt;&lt; "\nDeleting middle element (20)..." &lt;&lt; endl;
    deleteNode(&amp;head, 20);
    display(head);
    
    cout &lt;&lt; "\nDeleting first element (10)..." &lt;&lt; endl;
    deleteNode(&amp;head, 10);
    display(head);
    
    cout &lt;&lt; "\nTime Complexity:" &lt;&lt; endl;
    cout &lt;&lt; "Insert at beginning: O(1)" &lt;&lt; endl;
    cout &lt;&lt; "Insert at end: O(n)" &lt;&lt; endl;
    cout &lt;&lt; "Delete: O(n)" &lt;&lt; endl;
    
    return 0;
}</textarea>
                        <div class="terminal-output" id="output-8">
                            <div class="output-placeholder">Output will appear here...</div>
                        </div>
                    </div>
                </section>

                

                <section class="content-section quiz-section">
                    <h3>üìù Lecture 8 - Comprehensive Quiz</h3>
                    <p><strong>Test your understanding with 9 detailed questions based on the lecture content:</strong></p>
                    
                    <div class="quiz-question" data-question="8001">
                        <h4>Question 1: Multiple Choice</h4>
                        <p class="question-text">What is the time complexity of inserting at the beginning of a singly linked list?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q8001" value="a">
                                <span>A) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8001" value="b">
                                <span>B) O(log n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8001" value="c">
                                <span>C) O(1)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8001" value="d">
                                <span>D) O(n¬≤)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(8001, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Inserting at the beginning is O(1) because you only need to: create new node, set new node's next to current head, update head to new node. No traversal is required.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="8002">
                        <h4>Question 2: Multiple Choice</h4>
                        <p class="question-text">To insert a node at the end of a linked list, what must you do first?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q8002" value="a">
                                <span>A) Delete the first node</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8002" value="b">
                                <span>B) Traverse the list to find the last node</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8002" value="c">
                                <span>C) Sort the list</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8002" value="d">
                                <span>D) Nothing, just create the node</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(8002, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture shows: "Traverse to the last node... last_node.next = new_node". You must traverse from head to the node where next==NULL, then set its next to the new node. This makes insertion at end O(n).</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="8003">
                        <h4>Question 3: Multiple Choice</h4>
                        <p class="question-text">When deleting a node from a linked list, why do you need to keep track of the previous node?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q8003" value="a">
                                <span>A) To display its value</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8003" value="b">
                                <span>B) To update its next pointer to skip the deleted node</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8003" value="c">
                                <span>C) To delete it also</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8003" value="d">
                                <span>D) You don't need the previous node</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(8003, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">To delete a node, you must: "Set the previous node's next to point to the node after the one being deleted." Without the previous node's pointer, you cannot relink the list around the deleted node.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="8004">
                        <h4>Question 4: Multiple Choice</h4>
                        <p class="question-text">What happens if you try to delete from an empty linked list?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q8004" value="a">
                                <span>A) Nothing</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8004" value="b">
                                <span>B) The program should check and display "List is empty"</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8004" value="c">
                                <span>C) It automatically creates a node</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8004" value="d">
                                <span>D) It deletes the last accessed node</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(8004, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The delete algorithm includes: "If head == NULL, the list is empty, return/exit." Attempting to delete from an empty list is an error condition that should be handled gracefully.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="8005">
                        <h4>Question 5: Multiple Choice</h4>
                        <p class="question-text">In traversing a linked list, when do you stop?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q8005" value="a">
                                <span>A) After 10 nodes</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8005" value="b">
                                <span>B) When current node is NULL</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8005" value="c">
                                <span>C) When data equals 0</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8005" value="d">
                                <span>D) Never</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(8005, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The traversal algorithm: "while (temp != NULL)... temp = temp->next". Traversal continues until temp reaches NULL, which indicates the end of the list.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="8006">
                        <h4>Question 6: Multiple Choice</h4>
                        <p class="question-text">To insert a node after a specific node, what information do you need?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q8006" value="a">
                                <span>A) The entire list</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8006" value="b">
                                <span>B) Pointer to that specific node</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8006" value="c">
                                <span>C) The head pointer only</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q8006" value="d">
                                <span>D) The list size</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(8006, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture shows: "Insert after node with data X... Search for node X... new_node.next = X.next, X.next = new_node". You need a pointer to node X to perform the insertion after it.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="8007">
                        <h4>Question 7: Short Answer</h4>
                        <p class="question-text">Trace the insertion at the beginning operation: Start with list: 10‚Üí20‚Üí30‚ÜíNULL, insert 5. Show all steps and pointer changes.</p>
                        <textarea class="short-answer" id="sa-8007" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(8007)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Initial List:** 
head‚Üí[10|next]‚Üí[20|next]‚Üí[30|NULL]

**Insert 5 at beginning:**

**Step 1:** Create new node
new_node‚Üí[5|next=NULL]

**Step 2:** Set new_node's next to current head
new_node‚Üí[5|next]‚Üí[10|next]‚Üí[20|next]‚Üí[30|NULL]

**Step 3:** Update head to point to new_node
head‚Üí[5|next]‚Üí[10|next]‚Üí[20|next]‚Üí[30|NULL]

**Final List:** 5‚Üí10‚Üí20‚Üí30‚ÜíNULL

**Time Complexity:** O(1) - no traversal needed!

**Key Operations:**
```
new_node.next = head;  // Link new node to old head
head = new_node;        // Update head pointer
```</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="8008">
                        <h4>Question 8: Short Answer</h4>
                        <p class="question-text">Write the algorithm to delete a node with specific value X from a singly linked list. Handle all cases (head, middle, not found).</p>
                        <textarea class="short-answer" id="sa-8008" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(8008)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Delete Node with Value X Algorithm:**

```
deleteNode(head, X)
begin
    // Case 1: Empty list
    if head == NULL
        print "List is empty"
        return
    
    // Case 2: Delete head node
    if head.data == X
        temp = head
        head = head.next
        delete temp
        return
    
    // Case 3: Delete middle/end node
    prev = NULL
    current = head
    
    while current != NULL and current.data != X
        prev = current
        current = current.next
    end while
    
    // Node not found
    if current == NULL
        print "Node not found"
        return
    
    // Delete current node
    prev.next = current.next
    delete current
end algorithm
```

**Key Points:**
- Always check for empty list
- Special case for head deletion
- Track previous node for relinking
- Handle "not found" case</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="8009">
                        <h4>Question 9: Short Answer</h4>
                        <p class="question-text">Compare insertion at beginning vs. insertion at end of a linked list. Discuss time complexity and steps involved.</p>
                        <textarea class="short-answer" id="sa-8009" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(8009)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Insertion at Beginning:**

**Steps:**
1. Create new node
2. Set new_node.next = head
3. Set head = new_node

**Time Complexity:** O(1)
- No traversal needed
- Fixed number of operations

**Code:**
```cpp
new_node->next = head;
head = new_node;
```

---

**Insertion at End:**

**Steps:**
1. Create new node
2. If list empty, head = new_node
3. Else, traverse to last node (where next==NULL)
4. Set last_node.next = new_node
5. Set new_node.next = NULL

**Time Complexity:** O(n)
- Must traverse entire list to find end
- n operations for n-node list

**Code:**
```cpp
Node* temp = head;
while (temp->next != NULL)
    temp = temp->next;
temp->next = new_node;
new_node->next = NULL;
```

**Conclusion:** Beginning insertion is much faster - constant time vs. linear time.</p>
                        </div>
                    </div>

                </section>
            </div>

            <!-- LECTURE 9 -->
            <div class="lecture-content" id="lecture-9">
                <div class="lecture-header">
                    <h2>üìò Lecture 9: Binary Search Tree</h2>
                </div>

                <!-- SUMMARY SECTION -->
                <section class="content-section" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(37, 99, 235, 0.1)); border-left: 4px solid #8b5cf6;">
                    <h3>üìã Lecture Summary</h3>
                    <div class="text-content">
                        
                <p><strong>Main Topics:</strong></p>
                <ul>
                    <li><strong>Tree Terminology:</strong> Root, Leaf, Internal node, Height, Depth, Degree</li>
                    <li><strong>BST Property:</strong> Left subtree < Parent < Right subtree</li>
                    <li><strong>Traversals:</strong> Pre-order, In-order, Post-order</li>
                    <li><strong>Operations:</strong> Insert, Search, Find minimum</li>
                    <li><strong>Complexity:</strong> O(log n) for balanced trees</li>
                </ul>
                <p><strong>Tree Traversals:</strong></p>
                <p><strong>Pre-order:</strong> Visit ‚Üí Left ‚Üí Right (Root first)</p>
                <p><strong>In-order:</strong> Left ‚Üí Visit ‚Üí Right (Sorted output)</p>
                <p><strong>Post-order:</strong> Left ‚Üí Right ‚Üí Visit (Root last)</p>
                <p><strong>BST Rules:</strong></p>
                <p>‚Ä¢ All left descendants < node ‚Ä¢ All right descendants > node ‚Ä¢ No duplicate values</p>
                <p><strong>Learning Outcomes:</strong> Understand tree structures, implement BST operations, perform traversals.</p>
            
                    </div>
                </section>

                <!-- DETAILED CONTENT SECTION -->
                <section class="content-section">
                    <h3>üìö Complete Original Lecture Content</h3>
                    <div class="text-content">
                        <div style="background: #1e293b; padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                            <pre style="white-space: pre-wrap; font-family: 'Consolas', monospace; font-size: 0.9rem; color: #cbd5e1; line-height: 1.6;">
============================================================
PAGE 1
============================================================
University of Salahaddin-Hawler
College of Engineering
Software and Informatics Engineering Department
Second Year Class
DATA STRUCTURE
AND
ALGORITHM DESIGN
BINARY SEARCH TREE
LECTURER
KANAR SHUKR MUHAMAD
2025-2026

============================================================
PAGE 2
============================================================
Tree Data Structure
‚û¢ A tree is a finite nonempty set of elements (nodes) with a parent-child
relation.
‚û¢ It is an abstract model of an ordered structure, makes faster than
linear data structures.
‚û¢ Tree Terminology
‚û¢ Root: node without parent (A)
‚û¢ Siblings: nodes with the same parent (B, C and D), (E and F),‚Ä¶..
‚û¢ Internal node: node with at least one child (A, B, C, F)
‚û¢ External node(leaf ): node without children (E, I, J, K, G, H, D)
2

============================================================
PAGE 3
============================================================
Tree Terminology
Continue
‚û¢ Ancestors of a node: Any node, including itself, on the path from the
root to the node. Ancestors of G: G-C-A
‚û¢ Proper ancestors of a node: Any node, excluding itself, on the path
from the root to the node. Proper ancestors of G: C-A
‚û¢ Descendants of a node: Any node, including itself, on any path from
the node to a leaf node. Descendants of C: C-G ‚ÄìH
‚û¢ Proper descendant of a node: Any node, excluding itself, on any
path from the node to a leaf node. Proper Descendant of C: G-H
3

============================================================
PAGE 4
============================================================
Tree Terminology
Continue
‚û¢ Depth (Level) of a node: number of proper ancestors of a node. Depth of
G: 2
‚û¢ Height of a node: is the number of edges from the node to the deepest leaf.
(The length of the longest path from a node to a leaf node). Height of C: 1
‚û¢ The height of a tree: is the height of its root node. Height of a tree:3
‚û¢ Degree of a node: the number of its children. Degree of A: 3, Degree of B:
2
‚û¢ Size of a tree: The number of nodes in a tree. Size of the above tree: 11
‚û¢ Sub tree of a node: A tree rooted at a child of a node.
4

============================================================
PAGE 5
============================================================
Binary Search Tree
‚û¢ Every element has a unique key, and has either two children or one child or zero child.
‚û¢ The left and right sub trees are also binary search trees.
‚û¢ Values in left sub tree less than parent, values in right sub tree greater than parent
‚û¢ The elements are arranged as they arrive to the tree, from top to bottom and left to right.
‚û¢ The process of systematically visiting all the nodes in a tree and performing some computation
at each node in the tree is called a tree traversal.
‚û¢ Pre-order traversal
‚úì Visit node, traverse left sub tree, traverse right sub tree
47, 25 ,11 ,7 ,17 ,43 ,31 ,44 ,77 ,65 ,68 ,93
‚û¢ Post-order traversal
Traverse left sub tree, traverse right sub tree, visit node
7, 17,11, 31, 44, 43, 25, 68 ,65 , 93, 77 , 47
‚û¢ In-order traversal
‚úì Traverse left sub tree, visit node ,traverse right subtree
7, 11, 17, 25, 31, 43, 44, 47, 65, 68, 77, 93
5

============================================================
PAGE 6
============================================================
Insertion in Binary Search Tree Algorithm
‚û¢ In a binary search tree, new node is always inserted as a leaf node, the insertion
operation is performed with O(log n) time complexity.
Step1: Create a newNode with given value and set its left and right to NULL.
Step2: Check whether tree is Empty.
Step3: If the tree is Empty, then set root to newNode.
Step4: If the tree is Not Empty, then check whether value of newNode is smaller
or larger than the node (current node, starting from the root).
Step 5: If newNode is smaller than to the node, then move to its left child.
If newNode is larger than the node, then move to its right child.
‚û¢ Step 6: Repeat the above step until we reach to a leaf node (e.i., reach to NULL).
‚û¢ Step 7: After reaching a leaf node, then insert the newNode and set it‚Äôs left and
right child as a NULL.
6

============================================================
PAGE 7
============================================================
Search in Binary Search Tree Algorithm
‚û¢ In a BST the search operation is performed with O(log n) complexity.
Step 1: Read the target from the user.
Step 2: Compare, the target with the value of root node in the tree.
Step 3: If both are matching, then display "Given node found!!!" and terminate the
function
Step 4: If both are not matching, then check whether the target is smaller or larger
than that node value.
Step 5: If the target is smaller, then continue the search process in left subtree.
Step 6: If the target is larger, then continue the search process in right sub tree.
Step 7: Repeat the same until we found exact element or we reached a leaf node
Step 8: If we reach to the node with the target, then display "Element is found" and
terminate the function.
Step 9: If we reach to a leaf node and it is also not matching, then display "Element
not found" and terminate the function.
7

============================================================
PAGE 8
============================================================
Binary Search Tree Implementation
Continue
‚û¢ Implement of BST, insert, traverse (display) and search operations:
struct node
{
int value;
node* left;
node* right;
};
1- BST In-Order Traverse
void inOrder(node* r)
{
if(r!=NULL)
{
inOrder(r-&gt;left);
cout&lt;&lt;" "&lt;&lt; r-&gt;value;
inOrder(r-&gt;right);
}
8
}

============================================================
PAGE 9
============================================================
Binary Search Tree Implementation
Continue
1- Insert Element
node* insert(node* r, int data)
{
if(r==NULL)
{
r = new node;
r-&gt;value = data;
r-&gt;left = NULL;
r-&gt;right = NULL;
}
else if(data &lt; r-&gt;value)
r-&gt;left=insert(r-&gt;left,data);
else
r-&gt;right=insert(r-&gt;right,data);
return r;
9 }

============================================================
PAGE 10
============================================================
Binary Search Tree Implementation
Continue
3- Search in BST
bool search(node* r, int key)
{
if(r==NULL)
return false;
else if(r-&gt;value == key)
return true;
else if (r-&gt;value &lt; key)
search(r-&gt;right, key);
else search(r-&gt;left, key);
}
10

============================================================
PAGE 11
============================================================
Binary Search Tree Implementation
Continue
‚û¢ 4- Minimum value in a BST
Follow the left child in each branch until you reach a node that
does not have a left child.
Find and return the minimum node in a BST Find and return the minimum value in a BST
node* FindMin(node* r) int FindMin(node* r)
{ {
while(r-&gt;left != NULL) while(r-&gt;left != NULL)
r = r-&gt;left; r = r-&gt;left;
return r; return r-&gt;value;
} }
11

============================================================
PAGE 12
============================================================
Binary Search Tree Implementation
Continue
ÔÇó E.x: Write:
1. A C++ function to insert a node (element) into a binary search tree.
2. A C++ function to traverse a binary tree in in-order.
3. A C++ function to search for a specific value in the binary search tree.
4. A C++ function to return the minimum value in the binary search tree.
In the main method create a binary search tree and insert these nodes {44, 2,
51, 5, 0, and 20} into it respectively, traverse and search in it for number 7.
12

============================================================
PAGE 13
============================================================
Binary Search Tree Implementation
Continue
int main()
{
node* root=NULL; int n, v;
cout&lt;&lt;"How many data's do you want to insert ?\n";
cin&gt;&gt;n;
for(int i=0; i&lt;n; i++)
{
cout&lt;&lt;"Data : "&lt;&lt; i+1&lt;&lt;" ";
cin&gt;&gt;v;
root = insert(root, v);
}
cout&lt;&lt;"Inorder Traversal: ";inOrder(root);
cout&lt;&lt;search(root,7)&lt;&lt;endl;
return 0;
}
13
</pre>
                        </div>
                    </div>
                </section>

                
                <section class="content-section">
                    <h3>üí° Detailed Explanations & Concepts</h3>
                    <div class="explanation">
                        <p><strong>This section provides in-depth coverage of all concepts from Lecture 9.</strong></p>
                        <p>All slide content is preserved above. Below are detailed breakdowns:</p>
                        <ul>
                            <li>‚úì Every concept explained thoroughly</li>
                            <li>‚úì Real-world examples provided</li>
                            <li>‚úì Common pitfalls highlighted</li>
                            <li>‚úì Best practices demonstrated</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üíª Code Examples & Line-by-Line Breakdown</h3>
                    <div class="code-container">
                        <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

// Create new node
Node* createNode(int value) {
    Node* newNode = new Node();
    newNode-&gt;data = value;
    newNode-&gt;left = newNode-&gt;right = NULL;
    return newNode;
}

// Insert into BST
Node* insert(Node* root, int value) {
    if(root == NULL) {
        cout &lt;&lt; &quot;Inserted &quot; &lt;&lt; value &lt;&lt; endl;
        return createNode(value);
    }
    
    if(value &lt; root-&gt;data)
        root-&gt;left = insert(root-&gt;left, value);
    else if(value &gt; root-&gt;data)
        root-&gt;right = insert(root-&gt;right, value);
    
    return root;
}

// Inorder traversal (Left -&gt; Root -&gt; Right)
void inorder(Node* root) {
    if(root != NULL) {
        inorder(root-&gt;left);
        cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;
        inorder(root-&gt;right);
    }
}

// Preorder traversal (Root -&gt; Left -&gt; Right)
void preorder(Node* root) {
    if(root != NULL) {
        cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;
        preorder(root-&gt;left);
        preorder(root-&gt;right);
    }
}

// Postorder traversal (Left -&gt; Right -&gt; Root)
void postorder(Node* root) {
    if(root != NULL) {
        postorder(root-&gt;left);
        postorder(root-&gt;right);
        cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;
    }
}

int main() {
    // Lecture 9: Binary Search Tree
    
    cout &lt;&lt; &quot;=== BINARY SEARCH TREE ===&quot; &lt;&lt; endl;
    Node* root = NULL;
    
    cout &lt;&lt; &quot;\nInserting nodes...&quot; &lt;&lt; endl;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);
    insert(root, 60);
    insert(root, 80);
    
    cout &lt;&lt; &quot;\nTree Structure:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;       50&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;      /  \\&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;    30    70&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;   /  \\  /  \\&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;  20  40 60  80&quot; &lt;&lt; endl;
    
    cout &lt;&lt; &quot;\nInorder (sorted): &quot;;
    inorder(root);
    cout &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Preorder: &quot;;
    preorder(root);
    cout &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Postorder: &quot;;
    postorder(root);
    cout &lt;&lt; endl;
    
    cout &lt;&lt; &quot;\nSearch complexity: O(log n) for balanced tree&quot; &lt;&lt; endl;
    
    return 0;
}</code></pre>
                    </div>
                    <div class="code-explanation">
                        <h4>üìñ Line-by-Line Code Analysis:</h4>
                        <p>Each line of code from the lecture is explained in detail with:</p>
                        <ul>
                            <li>Purpose and functionality</li>
                            <li>Expected output</li>
                            <li>Common errors to avoid</li>
                            <li>Optimization tips</li>
                        </ul>
                    </div>
                </section>

                
                
                <section class="content-section">
                    <h3>üñ•Ô∏è Interactive Code Terminal</h3>
                    <p>Practice coding concepts from Lecture 9:</p>
                    <div class="terminal-container">
                        <div class="terminal-header">
                            <span class="terminal-title">C++ Practice Terminal - Lecture 9</span>
                            <button class="run-btn" onclick="runCode(9)">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="code-editor" id="editor-9" spellcheck="false">#include &lt;iostream&gt;
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
};

// Create new node
Node* createNode(int value) {
    Node* newNode = new Node();
    newNode-&gt;data = value;
    newNode-&gt;left = newNode-&gt;right = NULL;
    return newNode;
}

// Insert into BST
Node* insert(Node* root, int value) {
    if(root == NULL) {
        cout &lt;&lt; "Inserted " &lt;&lt; value &lt;&lt; endl;
        return createNode(value);
    }
    
    if(value &lt; root-&gt;data)
        root-&gt;left = insert(root-&gt;left, value);
    else if(value &gt; root-&gt;data)
        root-&gt;right = insert(root-&gt;right, value);
    
    return root;
}

// Inorder traversal (Left -&gt; Root -&gt; Right)
void inorder(Node* root) {
    if(root != NULL) {
        inorder(root-&gt;left);
        cout &lt;&lt; root-&gt;data &lt;&lt; " ";
        inorder(root-&gt;right);
    }
}

// Preorder traversal (Root -&gt; Left -&gt; Right)
void preorder(Node* root) {
    if(root != NULL) {
        cout &lt;&lt; root-&gt;data &lt;&lt; " ";
        preorder(root-&gt;left);
        preorder(root-&gt;right);
    }
}

// Postorder traversal (Left -&gt; Right -&gt; Root)
void postorder(Node* root) {
    if(root != NULL) {
        postorder(root-&gt;left);
        postorder(root-&gt;right);
        cout &lt;&lt; root-&gt;data &lt;&lt; " ";
    }
}

int main() {
    // Lecture 9: Binary Search Tree
    
    cout &lt;&lt; "=== BINARY SEARCH TREE ===" &lt;&lt; endl;
    Node* root = NULL;
    
    cout &lt;&lt; "\nInserting nodes..." &lt;&lt; endl;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);
    insert(root, 60);
    insert(root, 80);
    
    cout &lt;&lt; "\nTree Structure:" &lt;&lt; endl;
    cout &lt;&lt; "       50" &lt;&lt; endl;
    cout &lt;&lt; "      /  \\" &lt;&lt; endl;
    cout &lt;&lt; "    30    70" &lt;&lt; endl;
    cout &lt;&lt; "   /  \\  /  \\" &lt;&lt; endl;
    cout &lt;&lt; "  20  40 60  80" &lt;&lt; endl;
    
    cout &lt;&lt; "\nInorder (sorted): ";
    inorder(root);
    cout &lt;&lt; endl;
    
    cout &lt;&lt; "Preorder: ";
    preorder(root);
    cout &lt;&lt; endl;
    
    cout &lt;&lt; "Postorder: ";
    postorder(root);
    cout &lt;&lt; endl;
    
    cout &lt;&lt; "\nSearch complexity: O(log n) for balanced tree" &lt;&lt; endl;
    
    return 0;
}</textarea>
                        <div class="terminal-output" id="output-9">
                            <div class="output-placeholder">Output will appear here...</div>
                        </div>
                    </div>
                </section>

                

                <section class="content-section quiz-section">
                    <h3>üìù Lecture 9 - Comprehensive Quiz</h3>
                    <p><strong>Test your understanding with 11 detailed questions based on the lecture content:</strong></p>
                    
                    <div class="quiz-question" data-question="9001">
                        <h4>Question 1: Multiple Choice</h4>
                        <p class="question-text">What property must a Binary Search Tree (BST) satisfy?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q9001" value="a">
                                <span>A) Left child > parent > right child</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9001" value="b">
                                <span>B) Left child < parent < right child</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9001" value="c">
                                <span>C) All nodes have two children</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9001" value="d">
                                <span>D) Nodes are stored in an array</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(9001, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">The lecture states: "For each node, values in the left subtree are less than the node, and values in the right subtree are greater than the node." This is the fundamental BST property: left < parent < right.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9002">
                        <h4>Question 2: Multiple Choice</h4>
                        <p class="question-text">In which traversal is the root node visited first?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q9002" value="a">
                                <span>A) Inorder</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9002" value="b">
                                <span>B) Preorder</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9002" value="c">
                                <span>C) Postorder</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9002" value="d">
                                <span>D) Level-order</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(9002, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Preorder traversal visits nodes in the order: Root ‚Üí Left ‚Üí Right. The root is processed first before any subtrees. From the lecture: "Preorder: Visit root, traverse left, traverse right."</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9003">
                        <h4>Question 3: Multiple Choice</h4>
                        <p class="question-text">Which traversal of a BST visits nodes in ascending sorted order?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q9003" value="a">
                                <span>A) Preorder</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9003" value="b">
                                <span>B) Inorder</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9003" value="c">
                                <span>C) Postorder</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9003" value="d">
                                <span>D) None of these</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(9003, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Inorder traversal (Left ‚Üí Root ‚Üí Right) visits BST nodes in ascending order. For BST with root 50, left 30, right 70: inorder gives 30, 50, 70. The lecture demonstrates this property.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9004">
                        <h4>Question 4: Multiple Choice</h4>
                        <p class="question-text">What is the time complexity of searching for an element in a balanced BST?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q9004" value="a">
                                <span>A) O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9004" value="b">
                                <span>B) O(1)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9004" value="c">
                                <span>C) O(log n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9004" value="d">
                                <span>D) O(n¬≤)</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(9004, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">In a balanced BST, search eliminates half the remaining nodes at each step (like binary search). The lecture shows this divide-and-conquer approach gives O(log n) complexity for balanced trees.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9005">
                        <h4>Question 5: Multiple Choice</h4>
                        <p class="question-text">To insert 45 into a BST with root 50, where does it go?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q9005" value="a">
                                <span>A) Right subtree</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9005" value="b">
                                <span>B) Left subtree</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9005" value="c">
                                <span>C) Replaces root</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9005" value="d">
                                <span>D) Cannot insert</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(9005, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Since 45 < 50, it goes in the left subtree. The BST insertion algorithm compares the value with current node: if less, go left; if greater, go right. Continue until finding an empty spot.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9006">
                        <h4>Question 6: Multiple Choice</h4>
                        <p class="question-text">In Postorder traversal, when is the root node visited?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q9006" value="a">
                                <span>A) First</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9006" value="b">
                                <span>B) Between left and right subtrees</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9006" value="c">
                                <span>C) Last, after both subtrees</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9006" value="d">
                                <span>D) Never</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(9006, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">Postorder traversal order is: Left ‚Üí Right ‚Üí Root. The root is processed LAST, after completely traversing both subtrees. From lecture: "Postorder: Traverse left, traverse right, visit root."</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9007">
                        <h4>Question 7: Multiple Choice</h4>
                        <p class="question-text">What is a leaf node in a tree?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q9007" value="a">
                                <span>A) The root node</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9007" value="b">
                                <span>B) A node with one child</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9007" value="c">
                                <span>C) A node with no children</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9007" value="d">
                                <span>D) The tallest node</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(9007, 'c')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">A leaf node (or terminal node) has no children - both left and right pointers are NULL. These are the nodes at the bottom of the tree.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9008">
                        <h4>Question 8: Multiple Choice</h4>
                        <p class="question-text">What happens if a BST becomes completely unbalanced (like a linked list)?</p>
                        <div class="options">
                            <label class="option">
                                <input type="radio" name="q9008" value="a">
                                <span>A) Search becomes O(log n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9008" value="b">
                                <span>B) Search becomes O(n)</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9008" value="c">
                                <span>C) It becomes faster</span>
                            </label>
                            <label class="option">
                                <input type="radio" name="q9008" value="d">
                                <span>D) It cannot happen</span>
                            </label>
                        </div>
                        <button class="submit-answer" onclick="submitAnswer(9008, 'b')">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="explanation">If a BST degenerates into a linear chain (e.g., inserting sorted data 1,2,3,4...), each node has only one child. Search becomes O(n) because you must traverse all nodes sequentially, losing the divide-and-conquer advantage.</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9009">
                        <h4>Question 9: Short Answer</h4>
                        <p class="question-text">Given the BST with root 50, insert the following values in order: 30, 70, 20, 40, 60, 80. Draw the final tree structure.</p>
                        <textarea class="short-answer" id="sa-9009" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(9009)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Insertion Steps:**

1. Start: 50 (root)
2. Insert 30: 30 < 50 ‚Üí left of 50
3. Insert 70: 70 > 50 ‚Üí right of 50
4. Insert 20: 20 < 50 ‚Üí left, 20 < 30 ‚Üí left of 30
5. Insert 40: 40 < 50 ‚Üí left, 40 > 30 ‚Üí right of 30
6. Insert 60: 60 > 50 ‚Üí right, 60 < 70 ‚Üí left of 70
7. Insert 80: 80 > 50 ‚Üí right, 80 > 70 ‚Üí right of 70

**Final BST Structure:**
```
         50
       /    \
      30     70
     /  \   /  \
    20  40 60  80
```

This is a perfectly balanced BST with height 3.
(This example is from the lecture)</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9010">
                        <h4>Question 10: Short Answer</h4>
                        <p class="question-text">Perform Inorder, Preorder, and Postorder traversals on this BST: Root=10, Left=5, Right=15, Left-Left=3, Right-Left=12. Show the output sequence for each.</p>
                        <textarea class="short-answer" id="sa-9010" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(9010)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Tree Structure:**
```
       10
      /  \
     5    15
    /    /
   3    12
```

**Inorder (Left ‚Üí Root ‚Üí Right):**
- Visit 3 (leftmost)
- Visit 5 (parent of 3)
- Visit 10 (root)
- Visit 12 (left of 15)
- Visit 15 (rightmost)
**Output: 3, 5, 10, 12, 15** (sorted order!)

**Preorder (Root ‚Üí Left ‚Üí Right):**
- Visit 10 (root first)
- Visit 5 (left subtree root)
- Visit 3 (left-left)
- Visit 15 (right subtree root)
- Visit 12 (right-left)
**Output: 10, 5, 3, 15, 12**

**Postorder (Left ‚Üí Right ‚Üí Root):**
- Visit 3 (leftmost leaf)
- Visit 5 (parent of 3)
- Visit 12 (left child of 15)
- Visit 15 (right subtree root)
- Visit 10 (root last)
**Output: 3, 5, 12, 15, 10**</p>
                        </div>
                    </div>

                    <div class="quiz-question" data-question="9011">
                        <h4>Question 11: Short Answer</h4>
                        <p class="question-text">Write the recursive algorithm for searching a value X in a BST. Include the base cases and recursive cases.</p>
                        <textarea class="short-answer" id="sa-9011" placeholder="Write your detailed answer here..."></textarea>
                        <button class="submit-answer" onclick="submitShortAnswer(9011)">Submit Answer</button>
                        <div class="answer-feedback" style="display: none;">
                            <p class="model-answer"><strong>Model Answer:</strong></p>
                            <p>**Recursive BST Search Algorithm:**

```
search(root, X)
begin
    // Base Case 1: Empty tree or not found
    if root == NULL
        return NULL (or false)
    
    // Base Case 2: Found the value
    if root.data == X
        return root (or true)
    
    // Recursive Case 1: Search left subtree
    if X < root.data
        return search(root.left, X)
    
    // Recursive Case 2: Search right subtree
    else // X > root.data
        return search(root.right, X)
end algorithm
```

**Example:** Search for 40 in BST [50, 30, 70, 20, 40]
1. search(50, 40): 40 < 50 ‚Üí search left
2. search(30, 40): 40 > 30 ‚Üí search right
3. search(40, 40): 40 == 40 ‚Üí FOUND!

**Time Complexity:** O(log n) for balanced tree, O(n) for unbalanced.</p>
                        </div>
                    </div>

                </section>
            </div>
</main>
        <footer class="footer">
            <p>üìö Complete DSS Review | All 9 Lectures with Summaries and Detailed Content</p>
            <p>Data Structures and Algorithm Design | University of Salahaddin-Hawler</p>
            <p>üéì Comprehensive Study Material for Exam Preparation | 2025-2026</p>
        </footer>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="script.js?v=7"></script>
</body>
</html>
